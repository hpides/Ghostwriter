// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REMBRANDTPROTOCOL_REMBRANDT_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_REMBRANDTPROTOCOL_REMBRANDT_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace Rembrandt {
namespace Protocol {

struct BaseMessage;
struct BaseMessageBuilder;

struct Allocate;
struct AllocateBuilder;

struct Allocated;
struct AllocatedBuilder;

struct AllocateFailed;
struct AllocateFailedBuilder;

struct Free;
struct FreeBuilder;

struct Freed;
struct FreedBuilder;

struct FreeFailed;
struct FreeFailedBuilder;

struct Stage;
struct StageBuilder;

struct Staged;
struct StagedBuilder;

struct StageFailed;
struct StageFailedBuilder;

struct CommitRequest;
struct CommitRequestBuilder;

struct CommitResponse;
struct CommitResponseBuilder;

struct CommitException;
struct CommitExceptionBuilder;

struct Fetch;
struct FetchBuilder;

struct Fetched;
struct FetchedBuilder;

struct FetchFailed;
struct FetchFailedBuilder;

struct Initialize;
struct InitializeBuilder;

struct Initialized;
struct InitializedBuilder;

struct RequestRMemInfo;
struct RequestRMemInfoBuilder;

struct RMemInfo;
struct RMemInfoBuilder;

enum Message {
  Message_NONE = 0,
  Message_Allocate = 1,
  Message_Allocated = 2,
  Message_AllocateFailed = 3,
  Message_Free = 4,
  Message_Freed = 5,
  Message_Stage = 6,
  Message_Staged = 7,
  Message_StageFailed = 8,
  Message_CommitRequest = 9,
  Message_CommitResponse = 10,
  Message_CommitException = 11,
  Message_Fetch = 12,
  Message_Fetched = 13,
  Message_FetchFailed = 14,
  Message_Initialize = 15,
  Message_Initialized = 16,
  Message_RequestRMemInfo = 17,
  Message_RMemInfo = 18,
  Message_MIN = Message_NONE,
  Message_MAX = Message_RMemInfo
};

inline const Message (&EnumValuesMessage())[19] {
  static const Message values[] = {
    Message_NONE,
    Message_Allocate,
    Message_Allocated,
    Message_AllocateFailed,
    Message_Free,
    Message_Freed,
    Message_Stage,
    Message_Staged,
    Message_StageFailed,
    Message_CommitRequest,
    Message_CommitResponse,
    Message_CommitException,
    Message_Fetch,
    Message_Fetched,
    Message_FetchFailed,
    Message_Initialize,
    Message_Initialized,
    Message_RequestRMemInfo,
    Message_RMemInfo
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[20] = {
    "NONE",
    "Allocate",
    "Allocated",
    "AllocateFailed",
    "Free",
    "Freed",
    "Stage",
    "Staged",
    "StageFailed",
    "CommitRequest",
    "CommitResponse",
    "CommitException",
    "Fetch",
    "Fetched",
    "FetchFailed",
    "Initialize",
    "Initialized",
    "RequestRMemInfo",
    "RMemInfo",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_RMemInfo)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<Rembrandt::Protocol::Allocate> {
  static const Message enum_value = Message_Allocate;
};

template<> struct MessageTraits<Rembrandt::Protocol::Allocated> {
  static const Message enum_value = Message_Allocated;
};

template<> struct MessageTraits<Rembrandt::Protocol::AllocateFailed> {
  static const Message enum_value = Message_AllocateFailed;
};

template<> struct MessageTraits<Rembrandt::Protocol::Free> {
  static const Message enum_value = Message_Free;
};

template<> struct MessageTraits<Rembrandt::Protocol::Freed> {
  static const Message enum_value = Message_Freed;
};

template<> struct MessageTraits<Rembrandt::Protocol::Stage> {
  static const Message enum_value = Message_Stage;
};

template<> struct MessageTraits<Rembrandt::Protocol::Staged> {
  static const Message enum_value = Message_Staged;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageFailed> {
  static const Message enum_value = Message_StageFailed;
};

template<> struct MessageTraits<Rembrandt::Protocol::CommitRequest> {
  static const Message enum_value = Message_CommitRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::CommitResponse> {
  static const Message enum_value = Message_CommitResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::CommitException> {
  static const Message enum_value = Message_CommitException;
};

template<> struct MessageTraits<Rembrandt::Protocol::Fetch> {
  static const Message enum_value = Message_Fetch;
};

template<> struct MessageTraits<Rembrandt::Protocol::Fetched> {
  static const Message enum_value = Message_Fetched;
};

template<> struct MessageTraits<Rembrandt::Protocol::FetchFailed> {
  static const Message enum_value = Message_FetchFailed;
};

template<> struct MessageTraits<Rembrandt::Protocol::Initialize> {
  static const Message enum_value = Message_Initialize;
};

template<> struct MessageTraits<Rembrandt::Protocol::Initialized> {
  static const Message enum_value = Message_Initialized;
};

template<> struct MessageTraits<Rembrandt::Protocol::RequestRMemInfo> {
  static const Message enum_value = Message_RequestRMemInfo;
};

template<> struct MessageTraits<Rembrandt::Protocol::RMemInfo> {
  static const Message enum_value = Message_RMemInfo;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct BaseMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BaseMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_ID = 4,
    VT_CONTENT_TYPE = 6,
    VT_CONTENT = 8
  };
  uint64_t message_id() const {
    return GetField<uint64_t>(VT_MESSAGE_ID, 0);
  }
  Rembrandt::Protocol::Message content_type() const {
    return static_cast<Rembrandt::Protocol::Message>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const Rembrandt::Protocol::Allocate *content_as_Allocate() const {
    return content_type() == Rembrandt::Protocol::Message_Allocate ? static_cast<const Rembrandt::Protocol::Allocate *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::Allocated *content_as_Allocated() const {
    return content_type() == Rembrandt::Protocol::Message_Allocated ? static_cast<const Rembrandt::Protocol::Allocated *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::AllocateFailed *content_as_AllocateFailed() const {
    return content_type() == Rembrandt::Protocol::Message_AllocateFailed ? static_cast<const Rembrandt::Protocol::AllocateFailed *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::Free *content_as_Free() const {
    return content_type() == Rembrandt::Protocol::Message_Free ? static_cast<const Rembrandt::Protocol::Free *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::Freed *content_as_Freed() const {
    return content_type() == Rembrandt::Protocol::Message_Freed ? static_cast<const Rembrandt::Protocol::Freed *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::Stage *content_as_Stage() const {
    return content_type() == Rembrandt::Protocol::Message_Stage ? static_cast<const Rembrandt::Protocol::Stage *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::Staged *content_as_Staged() const {
    return content_type() == Rembrandt::Protocol::Message_Staged ? static_cast<const Rembrandt::Protocol::Staged *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageFailed *content_as_StageFailed() const {
    return content_type() == Rembrandt::Protocol::Message_StageFailed ? static_cast<const Rembrandt::Protocol::StageFailed *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::CommitRequest *content_as_CommitRequest() const {
    return content_type() == Rembrandt::Protocol::Message_CommitRequest ? static_cast<const Rembrandt::Protocol::CommitRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::CommitResponse *content_as_CommitResponse() const {
    return content_type() == Rembrandt::Protocol::Message_CommitResponse ? static_cast<const Rembrandt::Protocol::CommitResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::CommitException *content_as_CommitException() const {
    return content_type() == Rembrandt::Protocol::Message_CommitException ? static_cast<const Rembrandt::Protocol::CommitException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::Fetch *content_as_Fetch() const {
    return content_type() == Rembrandt::Protocol::Message_Fetch ? static_cast<const Rembrandt::Protocol::Fetch *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::Fetched *content_as_Fetched() const {
    return content_type() == Rembrandt::Protocol::Message_Fetched ? static_cast<const Rembrandt::Protocol::Fetched *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::FetchFailed *content_as_FetchFailed() const {
    return content_type() == Rembrandt::Protocol::Message_FetchFailed ? static_cast<const Rembrandt::Protocol::FetchFailed *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::Initialize *content_as_Initialize() const {
    return content_type() == Rembrandt::Protocol::Message_Initialize ? static_cast<const Rembrandt::Protocol::Initialize *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::Initialized *content_as_Initialized() const {
    return content_type() == Rembrandt::Protocol::Message_Initialized ? static_cast<const Rembrandt::Protocol::Initialized *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::RequestRMemInfo *content_as_RequestRMemInfo() const {
    return content_type() == Rembrandt::Protocol::Message_RequestRMemInfo ? static_cast<const Rembrandt::Protocol::RequestRMemInfo *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::RMemInfo *content_as_RMemInfo() const {
    return content_type() == Rembrandt::Protocol::Message_RMemInfo ? static_cast<const Rembrandt::Protocol::RMemInfo *>(content()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_ID) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyMessage(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Rembrandt::Protocol::Allocate *BaseMessage::content_as<Rembrandt::Protocol::Allocate>() const {
  return content_as_Allocate();
}

template<> inline const Rembrandt::Protocol::Allocated *BaseMessage::content_as<Rembrandt::Protocol::Allocated>() const {
  return content_as_Allocated();
}

template<> inline const Rembrandt::Protocol::AllocateFailed *BaseMessage::content_as<Rembrandt::Protocol::AllocateFailed>() const {
  return content_as_AllocateFailed();
}

template<> inline const Rembrandt::Protocol::Free *BaseMessage::content_as<Rembrandt::Protocol::Free>() const {
  return content_as_Free();
}

template<> inline const Rembrandt::Protocol::Freed *BaseMessage::content_as<Rembrandt::Protocol::Freed>() const {
  return content_as_Freed();
}

template<> inline const Rembrandt::Protocol::Stage *BaseMessage::content_as<Rembrandt::Protocol::Stage>() const {
  return content_as_Stage();
}

template<> inline const Rembrandt::Protocol::Staged *BaseMessage::content_as<Rembrandt::Protocol::Staged>() const {
  return content_as_Staged();
}

template<> inline const Rembrandt::Protocol::StageFailed *BaseMessage::content_as<Rembrandt::Protocol::StageFailed>() const {
  return content_as_StageFailed();
}

template<> inline const Rembrandt::Protocol::CommitRequest *BaseMessage::content_as<Rembrandt::Protocol::CommitRequest>() const {
  return content_as_CommitRequest();
}

template<> inline const Rembrandt::Protocol::CommitResponse *BaseMessage::content_as<Rembrandt::Protocol::CommitResponse>() const {
  return content_as_CommitResponse();
}

template<> inline const Rembrandt::Protocol::CommitException *BaseMessage::content_as<Rembrandt::Protocol::CommitException>() const {
  return content_as_CommitException();
}

template<> inline const Rembrandt::Protocol::Fetch *BaseMessage::content_as<Rembrandt::Protocol::Fetch>() const {
  return content_as_Fetch();
}

template<> inline const Rembrandt::Protocol::Fetched *BaseMessage::content_as<Rembrandt::Protocol::Fetched>() const {
  return content_as_Fetched();
}

template<> inline const Rembrandt::Protocol::FetchFailed *BaseMessage::content_as<Rembrandt::Protocol::FetchFailed>() const {
  return content_as_FetchFailed();
}

template<> inline const Rembrandt::Protocol::Initialize *BaseMessage::content_as<Rembrandt::Protocol::Initialize>() const {
  return content_as_Initialize();
}

template<> inline const Rembrandt::Protocol::Initialized *BaseMessage::content_as<Rembrandt::Protocol::Initialized>() const {
  return content_as_Initialized();
}

template<> inline const Rembrandt::Protocol::RequestRMemInfo *BaseMessage::content_as<Rembrandt::Protocol::RequestRMemInfo>() const {
  return content_as_RequestRMemInfo();
}

template<> inline const Rembrandt::Protocol::RMemInfo *BaseMessage::content_as<Rembrandt::Protocol::RMemInfo>() const {
  return content_as_RMemInfo();
}

struct BaseMessageBuilder {
  typedef BaseMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_id(uint64_t message_id) {
    fbb_.AddElement<uint64_t>(BaseMessage::VT_MESSAGE_ID, message_id, 0);
  }
  void add_content_type(Rembrandt::Protocol::Message content_type) {
    fbb_.AddElement<uint8_t>(BaseMessage::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(BaseMessage::VT_CONTENT, content);
  }
  explicit BaseMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaseMessageBuilder &operator=(const BaseMessageBuilder &);
  flatbuffers::Offset<BaseMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaseMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<BaseMessage> CreateBaseMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t message_id = 0,
    Rembrandt::Protocol::Message content_type = Rembrandt::Protocol::Message_NONE,
    flatbuffers::Offset<void> content = 0) {
  BaseMessageBuilder builder_(_fbb);
  builder_.add_message_id(message_id);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

struct Allocate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           verifier.EndTable();
  }
};

struct AllocateBuilder {
  typedef Allocate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(Allocate::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(Allocate::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(Allocate::VT_SEGMENT_ID, segment_id, 0);
  }
  explicit AllocateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocateBuilder &operator=(const AllocateBuilder &);
  flatbuffers::Offset<Allocate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Allocate>(end);
    return o;
  }
};

inline flatbuffers::Offset<Allocate> CreateAllocate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0) {
  AllocateBuilder builder_(_fbb);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct Allocated FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocatedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_OFFSET = 6
  };
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct AllocatedBuilder {
  typedef Allocated Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(Allocated::VT_SIZE, size, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(Allocated::VT_OFFSET, offset, 0);
  }
  explicit AllocatedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocatedBuilder &operator=(const AllocatedBuilder &);
  flatbuffers::Offset<Allocated> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Allocated>(end);
    return o;
  }
};

inline flatbuffers::Offset<Allocated> CreateAllocated(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t size = 0,
    uint64_t offset = 0) {
  AllocatedBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_size(size);
  return builder_.Finish();
}

struct AllocateFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct AllocateFailedBuilder {
  typedef AllocateFailed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(AllocateFailed::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(AllocateFailed::VT_ERROR_MESSAGE, error_message);
  }
  explicit AllocateFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocateFailedBuilder &operator=(const AllocateFailedBuilder &);
  flatbuffers::Offset<AllocateFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateFailed> CreateAllocateFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  AllocateFailedBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<AllocateFailed> CreateAllocateFailedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateAllocateFailed(
      _fbb,
      error_code,
      error_message__);
}

struct Free FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FreeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           verifier.EndTable();
  }
};

struct FreeBuilder {
  typedef Free Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(Free::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(Free::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(Free::VT_SEGMENT_ID, segment_id, 0);
  }
  explicit FreeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FreeBuilder &operator=(const FreeBuilder &);
  flatbuffers::Offset<Free> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Free>(end);
    return o;
  }
};

inline flatbuffers::Offset<Free> CreateFree(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0) {
  FreeBuilder builder_(_fbb);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct Freed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FreedBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FreedBuilder {
  typedef Freed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FreedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FreedBuilder &operator=(const FreedBuilder &);
  flatbuffers::Offset<Freed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Freed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Freed> CreateFreed(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FreedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FreeFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FreeFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct FreeFailedBuilder {
  typedef FreeFailed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(FreeFailed::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(FreeFailed::VT_ERROR_MESSAGE, error_message);
  }
  explicit FreeFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FreeFailedBuilder &operator=(const FreeFailedBuilder &);
  flatbuffers::Offset<FreeFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FreeFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<FreeFailed> CreateFreeFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  FreeFailedBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<FreeFailed> CreateFreeFailedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateFreeFailed(
      _fbb,
      error_code,
      error_message__);
}

struct Stage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_NUM_MESSAGES = 8,
    VT_TOTAL_SIZE = 10
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint16_t num_messages() const {
    return GetField<uint16_t>(VT_NUM_MESSAGES, 0);
  }
  uint32_t total_size() const {
    return GetField<uint32_t>(VT_TOTAL_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint16_t>(verifier, VT_NUM_MESSAGES) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_SIZE) &&
           verifier.EndTable();
  }
};

struct StageBuilder {
  typedef Stage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(Stage::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(Stage::VT_PARTITION_ID, partition_id, 0);
  }
  void add_num_messages(uint16_t num_messages) {
    fbb_.AddElement<uint16_t>(Stage::VT_NUM_MESSAGES, num_messages, 0);
  }
  void add_total_size(uint32_t total_size) {
    fbb_.AddElement<uint32_t>(Stage::VT_TOTAL_SIZE, total_size, 0);
  }
  explicit StageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageBuilder &operator=(const StageBuilder &);
  flatbuffers::Offset<Stage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stage>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stage> CreateStage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint16_t num_messages = 0,
    uint32_t total_size = 0) {
  StageBuilder builder_(_fbb);
  builder_.add_total_size(total_size);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  builder_.add_num_messages(num_messages);
  return builder_.Finish();
}

struct Staged FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StagedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4
  };
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct StagedBuilder {
  typedef Staged Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(Staged::VT_OFFSET, offset, 0);
  }
  explicit StagedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StagedBuilder &operator=(const StagedBuilder &);
  flatbuffers::Offset<Staged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Staged>(end);
    return o;
  }
};

inline flatbuffers::Offset<Staged> CreateStaged(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t offset = 0) {
  StagedBuilder builder_(_fbb);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct StageFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct StageFailedBuilder {
  typedef StageFailed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(StageFailed::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(StageFailed::VT_ERROR_MESSAGE, error_message);
  }
  explicit StageFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageFailedBuilder &operator=(const StageFailedBuilder &);
  flatbuffers::Offset<StageFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageFailed> CreateStageFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  StageFailedBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<StageFailed> CreateStageFailedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateStageFailed(
      _fbb,
      error_code,
      error_message__);
}

struct CommitRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommitRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_OFFSET = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct CommitRequestBuilder {
  typedef CommitRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(CommitRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(CommitRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(CommitRequest::VT_OFFSET, offset, 0);
  }
  explicit CommitRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitRequestBuilder &operator=(const CommitRequestBuilder &);
  flatbuffers::Offset<CommitRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommitRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommitRequest> CreateCommitRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint64_t offset = 0) {
  CommitRequestBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct CommitResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommitResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4
  };
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct CommitResponseBuilder {
  typedef CommitResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(CommitResponse::VT_OFFSET, offset, 0);
  }
  explicit CommitResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitResponseBuilder &operator=(const CommitResponseBuilder &);
  flatbuffers::Offset<CommitResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommitResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommitResponse> CreateCommitResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t offset = 0) {
  CommitResponseBuilder builder_(_fbb);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct CommitException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommitExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct CommitExceptionBuilder {
  typedef CommitException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(CommitException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(CommitException::VT_ERROR_MESSAGE, error_message);
  }
  explicit CommitExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitExceptionBuilder &operator=(const CommitExceptionBuilder &);
  flatbuffers::Offset<CommitException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommitException>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommitException> CreateCommitException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  CommitExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommitException> CreateCommitExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateCommitException(
      _fbb,
      error_code,
      error_message__);
}

struct Fetch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           verifier.EndTable();
  }
};

struct FetchBuilder {
  typedef Fetch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(Fetch::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(Fetch::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(Fetch::VT_SEGMENT_ID, segment_id, 0);
  }
  explicit FetchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchBuilder &operator=(const FetchBuilder &);
  flatbuffers::Offset<Fetch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fetch>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fetch> CreateFetch(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0) {
  FetchBuilder builder_(_fbb);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct Fetched FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_OFFSET = 4,
    VT_COMMIT_OFFSET = 6,
    VT_IS_COMMITTABLE = 8
  };
  uint64_t start_offset() const {
    return GetField<uint64_t>(VT_START_OFFSET, 0);
  }
  uint64_t commit_offset() const {
    return GetField<uint64_t>(VT_COMMIT_OFFSET, 0);
  }
  bool is_committable() const {
    return GetField<uint8_t>(VT_IS_COMMITTABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_START_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_COMMIT_OFFSET) &&
           VerifyField<uint8_t>(verifier, VT_IS_COMMITTABLE) &&
           verifier.EndTable();
  }
};

struct FetchedBuilder {
  typedef Fetched Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_offset(uint64_t start_offset) {
    fbb_.AddElement<uint64_t>(Fetched::VT_START_OFFSET, start_offset, 0);
  }
  void add_commit_offset(uint64_t commit_offset) {
    fbb_.AddElement<uint64_t>(Fetched::VT_COMMIT_OFFSET, commit_offset, 0);
  }
  void add_is_committable(bool is_committable) {
    fbb_.AddElement<uint8_t>(Fetched::VT_IS_COMMITTABLE, static_cast<uint8_t>(is_committable), 0);
  }
  explicit FetchedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchedBuilder &operator=(const FetchedBuilder &);
  flatbuffers::Offset<Fetched> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fetched>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fetched> CreateFetched(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start_offset = 0,
    uint64_t commit_offset = 0,
    bool is_committable = false) {
  FetchedBuilder builder_(_fbb);
  builder_.add_commit_offset(commit_offset);
  builder_.add_start_offset(start_offset);
  builder_.add_is_committable(is_committable);
  return builder_.Finish();
}

struct FetchFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  uint16_t error_message() const {
    return GetField<uint16_t>(VT_ERROR_MESSAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_MESSAGE) &&
           verifier.EndTable();
  }
};

struct FetchFailedBuilder {
  typedef FetchFailed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(FetchFailed::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(uint16_t error_message) {
    fbb_.AddElement<uint16_t>(FetchFailed::VT_ERROR_MESSAGE, error_message, 0);
  }
  explicit FetchFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchFailedBuilder &operator=(const FetchFailedBuilder &);
  flatbuffers::Offset<FetchFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FetchFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<FetchFailed> CreateFetchFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    uint16_t error_message = 0) {
  FetchFailedBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

struct Initialize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitializeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InitializeBuilder {
  typedef Initialize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InitializeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitializeBuilder &operator=(const InitializeBuilder &);
  flatbuffers::Offset<Initialize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Initialize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Initialize> CreateInitialize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InitializeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Initialized FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitializedBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InitializedBuilder {
  typedef Initialized Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InitializedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitializedBuilder &operator=(const InitializedBuilder &);
  flatbuffers::Offset<Initialized> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Initialized>(end);
    return o;
  }
};

inline flatbuffers::Offset<Initialized> CreateInitialized(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InitializedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RequestRMemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestRMemInfoBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestRMemInfoBuilder {
  typedef RequestRMemInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RequestRMemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestRMemInfoBuilder &operator=(const RequestRMemInfoBuilder &);
  flatbuffers::Offset<RequestRMemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequestRMemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestRMemInfo> CreateRequestRMemInfo(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RequestRMemInfoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RMemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RMemInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REMOTE_ADDRESS = 4,
    VT_REMOTE_KEY = 6
  };
  uint64_t remote_address() const {
    return GetField<uint64_t>(VT_REMOTE_ADDRESS, 0);
  }
  const flatbuffers::String *remote_key() const {
    return GetPointer<const flatbuffers::String *>(VT_REMOTE_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REMOTE_ADDRESS) &&
           VerifyOffset(verifier, VT_REMOTE_KEY) &&
           verifier.VerifyString(remote_key()) &&
           verifier.EndTable();
  }
};

struct RMemInfoBuilder {
  typedef RMemInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remote_address(uint64_t remote_address) {
    fbb_.AddElement<uint64_t>(RMemInfo::VT_REMOTE_ADDRESS, remote_address, 0);
  }
  void add_remote_key(flatbuffers::Offset<flatbuffers::String> remote_key) {
    fbb_.AddOffset(RMemInfo::VT_REMOTE_KEY, remote_key);
  }
  explicit RMemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RMemInfoBuilder &operator=(const RMemInfoBuilder &);
  flatbuffers::Offset<RMemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RMemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RMemInfo> CreateRMemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t remote_address = 0,
    flatbuffers::Offset<flatbuffers::String> remote_key = 0) {
  RMemInfoBuilder builder_(_fbb);
  builder_.add_remote_address(remote_address);
  builder_.add_remote_key(remote_key);
  return builder_.Finish();
}

inline flatbuffers::Offset<RMemInfo> CreateRMemInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t remote_address = 0,
    const char *remote_key = nullptr) {
  auto remote_key__ = remote_key ? _fbb.CreateString(remote_key) : 0;
  return Rembrandt::Protocol::CreateRMemInfo(
      _fbb,
      remote_address,
      remote_key__);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_Allocate: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Allocate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Allocated: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Allocated *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AllocateFailed: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::AllocateFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Free: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Free *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Freed: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Freed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Stage: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Stage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Staged: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Staged *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageFailed: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CommitRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::CommitRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CommitResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::CommitResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CommitException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::CommitException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Fetch: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Fetch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Fetched: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Fetched *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_FetchFailed: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::FetchFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Initialize: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Initialize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Initialized: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::Initialized *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_RequestRMemInfo: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::RequestRMemInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_RMemInfo: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::RMemInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Protocol
}  // namespace Rembrandt

#endif  // FLATBUFFERS_GENERATED_REMBRANDTPROTOCOL_REMBRANDT_PROTOCOL_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REMBRANDTPROTOCOL_REMBRANDT_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_REMBRANDTPROTOCOL_REMBRANDT_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace Rembrandt {
namespace Protocol {

struct BaseMessage;
struct BaseMessageBuilder;

struct AllocateRequest;
struct AllocateRequestBuilder;

struct AllocateResponse;
struct AllocateResponseBuilder;

struct AllocateException;
struct AllocateExceptionBuilder;

struct StageRequest;
struct StageRequestBuilder;

struct StageResponse;
struct StageResponseBuilder;

struct StageException;
struct StageExceptionBuilder;

struct CommitRequest;
struct CommitRequestBuilder;

struct CommitResponse;
struct CommitResponseBuilder;

struct CommitException;
struct CommitExceptionBuilder;

struct FetchRequest;
struct FetchRequestBuilder;

struct FetchResponse;
struct FetchResponseBuilder;

struct FetchException;
struct FetchExceptionBuilder;

struct InitializeRequest;
struct InitializeRequestBuilder;

struct InitializeResponse;
struct InitializeResponseBuilder;

struct RMemInfoRequest;
struct RMemInfoRequestBuilder;

struct RMemInfoResponse;
struct RMemInfoResponseBuilder;

enum Message {
  Message_NONE = 0,
  Message_AllocateRequest = 1,
  Message_AllocateResponse = 2,
  Message_AllocateException = 3,
  Message_CommitRequest = 4,
  Message_CommitResponse = 5,
  Message_CommitException = 6,
  Message_FetchRequest = 7,
  Message_FetchResponse = 8,
  Message_FetchException = 9,
  Message_InitializeRequest = 10,
  Message_InitializeResponse = 11,
  Message_RMemInfoRequest = 12,
  Message_RMemInfoResponse = 13,
  Message_StageRequest = 14,
  Message_StageResponse = 15,
  Message_StageException = 16,
  Message_MIN = Message_NONE,
  Message_MAX = Message_StageException
};

inline const Message (&EnumValuesMessage())[17] {
  static const Message values[] = {
    Message_NONE,
    Message_AllocateRequest,
    Message_AllocateResponse,
    Message_AllocateException,
    Message_CommitRequest,
    Message_CommitResponse,
    Message_CommitException,
    Message_FetchRequest,
    Message_FetchResponse,
    Message_FetchException,
    Message_InitializeRequest,
    Message_InitializeResponse,
    Message_RMemInfoRequest,
    Message_RMemInfoResponse,
    Message_StageRequest,
    Message_StageResponse,
    Message_StageException
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[18] = {
    "NONE",
    "AllocateRequest",
    "AllocateResponse",
    "AllocateException",
    "CommitRequest",
    "CommitResponse",
    "CommitException",
    "FetchRequest",
    "FetchResponse",
    "FetchException",
    "InitializeRequest",
    "InitializeResponse",
    "RMemInfoRequest",
    "RMemInfoResponse",
    "StageRequest",
    "StageResponse",
    "StageException",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_StageException)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<Rembrandt::Protocol::AllocateRequest> {
  static const Message enum_value = Message_AllocateRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::AllocateResponse> {
  static const Message enum_value = Message_AllocateResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::AllocateException> {
  static const Message enum_value = Message_AllocateException;
};

template<> struct MessageTraits<Rembrandt::Protocol::CommitRequest> {
  static const Message enum_value = Message_CommitRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::CommitResponse> {
  static const Message enum_value = Message_CommitResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::CommitException> {
  static const Message enum_value = Message_CommitException;
};

template<> struct MessageTraits<Rembrandt::Protocol::FetchRequest> {
  static const Message enum_value = Message_FetchRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::FetchResponse> {
  static const Message enum_value = Message_FetchResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::FetchException> {
  static const Message enum_value = Message_FetchException;
};

template<> struct MessageTraits<Rembrandt::Protocol::InitializeRequest> {
  static const Message enum_value = Message_InitializeRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::InitializeResponse> {
  static const Message enum_value = Message_InitializeResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::RMemInfoRequest> {
  static const Message enum_value = Message_RMemInfoRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::RMemInfoResponse> {
  static const Message enum_value = Message_RMemInfoResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageRequest> {
  static const Message enum_value = Message_StageRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageResponse> {
  static const Message enum_value = Message_StageResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageException> {
  static const Message enum_value = Message_StageException;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct BaseMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BaseMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_ID = 4,
    VT_CONTENT_TYPE = 6,
    VT_CONTENT = 8
  };
  uint64_t message_id() const {
    return GetField<uint64_t>(VT_MESSAGE_ID, 0);
  }
  Rembrandt::Protocol::Message content_type() const {
    return static_cast<Rembrandt::Protocol::Message>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const Rembrandt::Protocol::AllocateRequest *content_as_AllocateRequest() const {
    return content_type() == Rembrandt::Protocol::Message_AllocateRequest ? static_cast<const Rembrandt::Protocol::AllocateRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::AllocateResponse *content_as_AllocateResponse() const {
    return content_type() == Rembrandt::Protocol::Message_AllocateResponse ? static_cast<const Rembrandt::Protocol::AllocateResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::AllocateException *content_as_AllocateException() const {
    return content_type() == Rembrandt::Protocol::Message_AllocateException ? static_cast<const Rembrandt::Protocol::AllocateException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::CommitRequest *content_as_CommitRequest() const {
    return content_type() == Rembrandt::Protocol::Message_CommitRequest ? static_cast<const Rembrandt::Protocol::CommitRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::CommitResponse *content_as_CommitResponse() const {
    return content_type() == Rembrandt::Protocol::Message_CommitResponse ? static_cast<const Rembrandt::Protocol::CommitResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::CommitException *content_as_CommitException() const {
    return content_type() == Rembrandt::Protocol::Message_CommitException ? static_cast<const Rembrandt::Protocol::CommitException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::FetchRequest *content_as_FetchRequest() const {
    return content_type() == Rembrandt::Protocol::Message_FetchRequest ? static_cast<const Rembrandt::Protocol::FetchRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::FetchResponse *content_as_FetchResponse() const {
    return content_type() == Rembrandt::Protocol::Message_FetchResponse ? static_cast<const Rembrandt::Protocol::FetchResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::FetchException *content_as_FetchException() const {
    return content_type() == Rembrandt::Protocol::Message_FetchException ? static_cast<const Rembrandt::Protocol::FetchException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::InitializeRequest *content_as_InitializeRequest() const {
    return content_type() == Rembrandt::Protocol::Message_InitializeRequest ? static_cast<const Rembrandt::Protocol::InitializeRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::InitializeResponse *content_as_InitializeResponse() const {
    return content_type() == Rembrandt::Protocol::Message_InitializeResponse ? static_cast<const Rembrandt::Protocol::InitializeResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::RMemInfoRequest *content_as_RMemInfoRequest() const {
    return content_type() == Rembrandt::Protocol::Message_RMemInfoRequest ? static_cast<const Rembrandt::Protocol::RMemInfoRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::RMemInfoResponse *content_as_RMemInfoResponse() const {
    return content_type() == Rembrandt::Protocol::Message_RMemInfoResponse ? static_cast<const Rembrandt::Protocol::RMemInfoResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageRequest *content_as_StageRequest() const {
    return content_type() == Rembrandt::Protocol::Message_StageRequest ? static_cast<const Rembrandt::Protocol::StageRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageResponse *content_as_StageResponse() const {
    return content_type() == Rembrandt::Protocol::Message_StageResponse ? static_cast<const Rembrandt::Protocol::StageResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageException *content_as_StageException() const {
    return content_type() == Rembrandt::Protocol::Message_StageException ? static_cast<const Rembrandt::Protocol::StageException *>(content()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_ID) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyMessage(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Rembrandt::Protocol::AllocateRequest *BaseMessage::content_as<Rembrandt::Protocol::AllocateRequest>() const {
  return content_as_AllocateRequest();
}

template<> inline const Rembrandt::Protocol::AllocateResponse *BaseMessage::content_as<Rembrandt::Protocol::AllocateResponse>() const {
  return content_as_AllocateResponse();
}

template<> inline const Rembrandt::Protocol::AllocateException *BaseMessage::content_as<Rembrandt::Protocol::AllocateException>() const {
  return content_as_AllocateException();
}

template<> inline const Rembrandt::Protocol::CommitRequest *BaseMessage::content_as<Rembrandt::Protocol::CommitRequest>() const {
  return content_as_CommitRequest();
}

template<> inline const Rembrandt::Protocol::CommitResponse *BaseMessage::content_as<Rembrandt::Protocol::CommitResponse>() const {
  return content_as_CommitResponse();
}

template<> inline const Rembrandt::Protocol::CommitException *BaseMessage::content_as<Rembrandt::Protocol::CommitException>() const {
  return content_as_CommitException();
}

template<> inline const Rembrandt::Protocol::FetchRequest *BaseMessage::content_as<Rembrandt::Protocol::FetchRequest>() const {
  return content_as_FetchRequest();
}

template<> inline const Rembrandt::Protocol::FetchResponse *BaseMessage::content_as<Rembrandt::Protocol::FetchResponse>() const {
  return content_as_FetchResponse();
}

template<> inline const Rembrandt::Protocol::FetchException *BaseMessage::content_as<Rembrandt::Protocol::FetchException>() const {
  return content_as_FetchException();
}

template<> inline const Rembrandt::Protocol::InitializeRequest *BaseMessage::content_as<Rembrandt::Protocol::InitializeRequest>() const {
  return content_as_InitializeRequest();
}

template<> inline const Rembrandt::Protocol::InitializeResponse *BaseMessage::content_as<Rembrandt::Protocol::InitializeResponse>() const {
  return content_as_InitializeResponse();
}

template<> inline const Rembrandt::Protocol::RMemInfoRequest *BaseMessage::content_as<Rembrandt::Protocol::RMemInfoRequest>() const {
  return content_as_RMemInfoRequest();
}

template<> inline const Rembrandt::Protocol::RMemInfoResponse *BaseMessage::content_as<Rembrandt::Protocol::RMemInfoResponse>() const {
  return content_as_RMemInfoResponse();
}

template<> inline const Rembrandt::Protocol::StageRequest *BaseMessage::content_as<Rembrandt::Protocol::StageRequest>() const {
  return content_as_StageRequest();
}

template<> inline const Rembrandt::Protocol::StageResponse *BaseMessage::content_as<Rembrandt::Protocol::StageResponse>() const {
  return content_as_StageResponse();
}

template<> inline const Rembrandt::Protocol::StageException *BaseMessage::content_as<Rembrandt::Protocol::StageException>() const {
  return content_as_StageException();
}

struct BaseMessageBuilder {
  typedef BaseMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_id(uint64_t message_id) {
    fbb_.AddElement<uint64_t>(BaseMessage::VT_MESSAGE_ID, message_id, 0);
  }
  void add_content_type(Rembrandt::Protocol::Message content_type) {
    fbb_.AddElement<uint8_t>(BaseMessage::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(BaseMessage::VT_CONTENT, content);
  }
  explicit BaseMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaseMessageBuilder &operator=(const BaseMessageBuilder &);
  flatbuffers::Offset<BaseMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaseMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<BaseMessage> CreateBaseMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t message_id = 0,
    Rembrandt::Protocol::Message content_type = Rembrandt::Protocol::Message_NONE,
    flatbuffers::Offset<void> content = 0) {
  BaseMessageBuilder builder_(_fbb);
  builder_.add_message_id(message_id);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

struct AllocateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           verifier.EndTable();
  }
};

struct AllocateRequestBuilder {
  typedef AllocateRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(AllocateRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(AllocateRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(AllocateRequest::VT_SEGMENT_ID, segment_id, 0);
  }
  explicit AllocateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocateRequestBuilder &operator=(const AllocateRequestBuilder &);
  flatbuffers::Offset<AllocateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateRequest> CreateAllocateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0) {
  AllocateRequestBuilder builder_(_fbb);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct AllocateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_OFFSET = 6
  };
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct AllocateResponseBuilder {
  typedef AllocateResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(AllocateResponse::VT_SIZE, size, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(AllocateResponse::VT_OFFSET, offset, 0);
  }
  explicit AllocateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocateResponseBuilder &operator=(const AllocateResponseBuilder &);
  flatbuffers::Offset<AllocateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateResponse> CreateAllocateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t size = 0,
    uint64_t offset = 0) {
  AllocateResponseBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_size(size);
  return builder_.Finish();
}

struct AllocateException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct AllocateExceptionBuilder {
  typedef AllocateException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(AllocateException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(AllocateException::VT_ERROR_MESSAGE, error_message);
  }
  explicit AllocateExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocateExceptionBuilder &operator=(const AllocateExceptionBuilder &);
  flatbuffers::Offset<AllocateException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateException>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateException> CreateAllocateException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  AllocateExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<AllocateException> CreateAllocateExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateAllocateException(
      _fbb,
      error_code,
      error_message__);
}

struct StageRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_MESSAGE_SIZE = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint64_t message_size() const {
    return GetField<uint64_t>(VT_MESSAGE_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_SIZE) &&
           verifier.EndTable();
  }
};

struct StageRequestBuilder {
  typedef StageRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(StageRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(StageRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_message_size(uint64_t message_size) {
    fbb_.AddElement<uint64_t>(StageRequest::VT_MESSAGE_SIZE, message_size, 0);
  }
  explicit StageRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageRequestBuilder &operator=(const StageRequestBuilder &);
  flatbuffers::Offset<StageRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageRequest> CreateStageRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint64_t message_size = 0) {
  StageRequestBuilder builder_(_fbb);
  builder_.add_message_size(message_size);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct StageResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGICAL_OFFSET = 4,
    VT_REMOTE_LOCATION = 6
  };
  uint64_t logical_offset() const {
    return GetField<uint64_t>(VT_LOGICAL_OFFSET, 0);
  }
  uint64_t remote_location() const {
    return GetField<uint64_t>(VT_REMOTE_LOCATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LOGICAL_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_REMOTE_LOCATION) &&
           verifier.EndTable();
  }
};

struct StageResponseBuilder {
  typedef StageResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logical_offset(uint64_t logical_offset) {
    fbb_.AddElement<uint64_t>(StageResponse::VT_LOGICAL_OFFSET, logical_offset, 0);
  }
  void add_remote_location(uint64_t remote_location) {
    fbb_.AddElement<uint64_t>(StageResponse::VT_REMOTE_LOCATION, remote_location, 0);
  }
  explicit StageResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageResponseBuilder &operator=(const StageResponseBuilder &);
  flatbuffers::Offset<StageResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageResponse> CreateStageResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t logical_offset = 0,
    uint64_t remote_location = 0) {
  StageResponseBuilder builder_(_fbb);
  builder_.add_remote_location(remote_location);
  builder_.add_logical_offset(logical_offset);
  return builder_.Finish();
}

struct StageException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct StageExceptionBuilder {
  typedef StageException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(StageException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(StageException::VT_ERROR_MESSAGE, error_message);
  }
  explicit StageExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageExceptionBuilder &operator=(const StageExceptionBuilder &);
  flatbuffers::Offset<StageException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageException>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageException> CreateStageException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  StageExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<StageException> CreateStageExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateStageException(
      _fbb,
      error_code,
      error_message__);
}

struct CommitRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommitRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_LOGICAL_OFFSET = 8,
    VT_MESSAGE_SIZE = 10
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint64_t logical_offset() const {
    return GetField<uint64_t>(VT_LOGICAL_OFFSET, 0);
  }
  uint64_t message_size() const {
    return GetField<uint64_t>(VT_MESSAGE_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint64_t>(verifier, VT_LOGICAL_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_SIZE) &&
           verifier.EndTable();
  }
};

struct CommitRequestBuilder {
  typedef CommitRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(CommitRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(CommitRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_logical_offset(uint64_t logical_offset) {
    fbb_.AddElement<uint64_t>(CommitRequest::VT_LOGICAL_OFFSET, logical_offset, 0);
  }
  void add_message_size(uint64_t message_size) {
    fbb_.AddElement<uint64_t>(CommitRequest::VT_MESSAGE_SIZE, message_size, 0);
  }
  explicit CommitRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitRequestBuilder &operator=(const CommitRequestBuilder &);
  flatbuffers::Offset<CommitRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommitRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommitRequest> CreateCommitRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint64_t logical_offset = 0,
    uint64_t message_size = 0) {
  CommitRequestBuilder builder_(_fbb);
  builder_.add_message_size(message_size);
  builder_.add_logical_offset(logical_offset);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct CommitResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommitResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4
  };
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct CommitResponseBuilder {
  typedef CommitResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(CommitResponse::VT_OFFSET, offset, 0);
  }
  explicit CommitResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitResponseBuilder &operator=(const CommitResponseBuilder &);
  flatbuffers::Offset<CommitResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommitResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommitResponse> CreateCommitResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t offset = 0) {
  CommitResponseBuilder builder_(_fbb);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct CommitException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommitExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct CommitExceptionBuilder {
  typedef CommitException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(CommitException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(CommitException::VT_ERROR_MESSAGE, error_message);
  }
  explicit CommitExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitExceptionBuilder &operator=(const CommitExceptionBuilder &);
  flatbuffers::Offset<CommitException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommitException>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommitException> CreateCommitException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  CommitExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommitException> CreateCommitExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateCommitException(
      _fbb,
      error_code,
      error_message__);
}

struct FetchRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_LOGICAL_OFFSET = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint64_t logical_offset() const {
    return GetField<uint64_t>(VT_LOGICAL_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint64_t>(verifier, VT_LOGICAL_OFFSET) &&
           verifier.EndTable();
  }
};

struct FetchRequestBuilder {
  typedef FetchRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(FetchRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(FetchRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_logical_offset(uint64_t logical_offset) {
    fbb_.AddElement<uint64_t>(FetchRequest::VT_LOGICAL_OFFSET, logical_offset, 0);
  }
  explicit FetchRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchRequestBuilder &operator=(const FetchRequestBuilder &);
  flatbuffers::Offset<FetchRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FetchRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FetchRequest> CreateFetchRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint64_t logical_offset = 0) {
  FetchRequestBuilder builder_(_fbb);
  builder_.add_logical_offset(logical_offset);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct FetchResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REMOTE_LOCATION = 4,
    VT_COMMIT_OFFSET = 6
  };
  uint64_t remote_location() const {
    return GetField<uint64_t>(VT_REMOTE_LOCATION, 0);
  }
  uint64_t commit_offset() const {
    return GetField<uint64_t>(VT_COMMIT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REMOTE_LOCATION) &&
           VerifyField<uint64_t>(verifier, VT_COMMIT_OFFSET) &&
           verifier.EndTable();
  }
};

struct FetchResponseBuilder {
  typedef FetchResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remote_location(uint64_t remote_location) {
    fbb_.AddElement<uint64_t>(FetchResponse::VT_REMOTE_LOCATION, remote_location, 0);
  }
  void add_commit_offset(uint64_t commit_offset) {
    fbb_.AddElement<uint64_t>(FetchResponse::VT_COMMIT_OFFSET, commit_offset, 0);
  }
  explicit FetchResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchResponseBuilder &operator=(const FetchResponseBuilder &);
  flatbuffers::Offset<FetchResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FetchResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FetchResponse> CreateFetchResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t remote_location = 0,
    uint64_t commit_offset = 0) {
  FetchResponseBuilder builder_(_fbb);
  builder_.add_commit_offset(commit_offset);
  builder_.add_remote_location(remote_location);
  return builder_.Finish();
}

struct FetchException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  uint16_t error_message() const {
    return GetField<uint16_t>(VT_ERROR_MESSAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_MESSAGE) &&
           verifier.EndTable();
  }
};

struct FetchExceptionBuilder {
  typedef FetchException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(FetchException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(uint16_t error_message) {
    fbb_.AddElement<uint16_t>(FetchException::VT_ERROR_MESSAGE, error_message, 0);
  }
  explicit FetchExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchExceptionBuilder &operator=(const FetchExceptionBuilder &);
  flatbuffers::Offset<FetchException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FetchException>(end);
    return o;
  }
};

inline flatbuffers::Offset<FetchException> CreateFetchException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    uint16_t error_message = 0) {
  FetchExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

struct InitializeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitializeRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InitializeRequestBuilder {
  typedef InitializeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InitializeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitializeRequestBuilder &operator=(const InitializeRequestBuilder &);
  flatbuffers::Offset<InitializeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InitializeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InitializeRequest> CreateInitializeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InitializeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct InitializeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitializeResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InitializeResponseBuilder {
  typedef InitializeResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InitializeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitializeResponseBuilder &operator=(const InitializeResponseBuilder &);
  flatbuffers::Offset<InitializeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InitializeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InitializeResponse> CreateInitializeResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InitializeResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RMemInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RMemInfoRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RMemInfoRequestBuilder {
  typedef RMemInfoRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RMemInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RMemInfoRequestBuilder &operator=(const RMemInfoRequestBuilder &);
  flatbuffers::Offset<RMemInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RMemInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RMemInfoRequest> CreateRMemInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RMemInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RMemInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RMemInfoResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REMOTE_ADDRESS = 4,
    VT_REMOTE_KEY = 6
  };
  uint64_t remote_address() const {
    return GetField<uint64_t>(VT_REMOTE_ADDRESS, 0);
  }
  const flatbuffers::String *remote_key() const {
    return GetPointer<const flatbuffers::String *>(VT_REMOTE_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REMOTE_ADDRESS) &&
           VerifyOffset(verifier, VT_REMOTE_KEY) &&
           verifier.VerifyString(remote_key()) &&
           verifier.EndTable();
  }
};

struct RMemInfoResponseBuilder {
  typedef RMemInfoResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remote_address(uint64_t remote_address) {
    fbb_.AddElement<uint64_t>(RMemInfoResponse::VT_REMOTE_ADDRESS, remote_address, 0);
  }
  void add_remote_key(flatbuffers::Offset<flatbuffers::String> remote_key) {
    fbb_.AddOffset(RMemInfoResponse::VT_REMOTE_KEY, remote_key);
  }
  explicit RMemInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RMemInfoResponseBuilder &operator=(const RMemInfoResponseBuilder &);
  flatbuffers::Offset<RMemInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RMemInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RMemInfoResponse> CreateRMemInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t remote_address = 0,
    flatbuffers::Offset<flatbuffers::String> remote_key = 0) {
  RMemInfoResponseBuilder builder_(_fbb);
  builder_.add_remote_address(remote_address);
  builder_.add_remote_key(remote_key);
  return builder_.Finish();
}

inline flatbuffers::Offset<RMemInfoResponse> CreateRMemInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t remote_address = 0,
    const char *remote_key = nullptr) {
  auto remote_key__ = remote_key ? _fbb.CreateString(remote_key) : 0;
  return Rembrandt::Protocol::CreateRMemInfoResponse(
      _fbb,
      remote_address,
      remote_key__);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_AllocateRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::AllocateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AllocateResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::AllocateResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AllocateException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::AllocateException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CommitRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::CommitRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CommitResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::CommitResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CommitException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::CommitException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_FetchRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::FetchRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_FetchResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::FetchResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_FetchException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::FetchException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_InitializeRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::InitializeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_InitializeResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::InitializeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_RMemInfoRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::RMemInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_RMemInfoResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::RMemInfoResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Protocol
}  // namespace Rembrandt

#endif  // FLATBUFFERS_GENERATED_REMBRANDTPROTOCOL_REMBRANDT_PROTOCOL_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REMBRANDTPROTOCOL_REMBRANDT_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_REMBRANDTPROTOCOL_REMBRANDT_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace Rembrandt {
namespace Protocol {

struct BaseMessage;
struct BaseMessageBuilder;

struct AllocateRequest;
struct AllocateRequestBuilder;

struct AllocateResponse;
struct AllocateResponseBuilder;

struct AllocateException;
struct AllocateExceptionBuilder;

struct StageMessageRequest;
struct StageMessageRequestBuilder;

struct StageMessageResponse;
struct StageMessageResponseBuilder;

struct StageMessageException;
struct StageMessageExceptionBuilder;

struct StageOffsetRequest;
struct StageOffsetRequestBuilder;

struct StageOffsetResponse;
struct StageOffsetResponseBuilder;

struct StageOffsetException;
struct StageOffsetExceptionBuilder;

struct CommitRequest;
struct CommitRequestBuilder;

struct CommitResponse;
struct CommitResponseBuilder;

struct CommitException;
struct CommitExceptionBuilder;

struct FetchRequest;
struct FetchRequestBuilder;

struct FetchResponse;
struct FetchResponseBuilder;

struct FetchException;
struct FetchExceptionBuilder;

struct InitializeRequest;
struct InitializeRequestBuilder;

struct InitializeResponse;
struct InitializeResponseBuilder;

struct ReadSegmentRequest;
struct ReadSegmentRequestBuilder;

struct ReadSegmentResponse;
struct ReadSegmentResponseBuilder;

struct ReadSegmentException;
struct ReadSegmentExceptionBuilder;

struct RMemInfoRequest;
struct RMemInfoRequestBuilder;

struct RMemInfoResponse;
struct RMemInfoResponseBuilder;

struct WriteSegmentRequest;
struct WriteSegmentRequestBuilder;

struct WriteSegmentResponse;
struct WriteSegmentResponseBuilder;

struct WriteSegmentException;
struct WriteSegmentExceptionBuilder;

enum Message {
  Message_NONE = 0,
  Message_AllocateRequest = 1,
  Message_AllocateResponse = 2,
  Message_AllocateException = 3,
  Message_CommitRequest = 4,
  Message_CommitResponse = 5,
  Message_CommitException = 6,
  Message_FetchRequest = 7,
  Message_FetchResponse = 8,
  Message_FetchException = 9,
  Message_InitializeRequest = 10,
  Message_InitializeResponse = 11,
  Message_ReadSegmentRequest = 12,
  Message_ReadSegmentResponse = 13,
  Message_ReadSegmentException = 14,
  Message_RMemInfoRequest = 15,
  Message_RMemInfoResponse = 16,
  Message_StageMessageRequest = 17,
  Message_StageMessageResponse = 18,
  Message_StageMessageException = 19,
  Message_StageOffsetRequest = 20,
  Message_StageOffsetResponse = 21,
  Message_StageOffsetException = 22,
  Message_WriteSegmentRequest = 23,
  Message_WriteSegmentResponse = 24,
  Message_WriteSegmentException = 25,
  Message_MIN = Message_NONE,
  Message_MAX = Message_WriteSegmentException
};

inline const Message (&EnumValuesMessage())[26] {
  static const Message values[] = {
    Message_NONE,
    Message_AllocateRequest,
    Message_AllocateResponse,
    Message_AllocateException,
    Message_CommitRequest,
    Message_CommitResponse,
    Message_CommitException,
    Message_FetchRequest,
    Message_FetchResponse,
    Message_FetchException,
    Message_InitializeRequest,
    Message_InitializeResponse,
    Message_ReadSegmentRequest,
    Message_ReadSegmentResponse,
    Message_ReadSegmentException,
    Message_RMemInfoRequest,
    Message_RMemInfoResponse,
    Message_StageMessageRequest,
    Message_StageMessageResponse,
    Message_StageMessageException,
    Message_StageOffsetRequest,
    Message_StageOffsetResponse,
    Message_StageOffsetException,
    Message_WriteSegmentRequest,
    Message_WriteSegmentResponse,
    Message_WriteSegmentException
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[27] = {
    "NONE",
    "AllocateRequest",
    "AllocateResponse",
    "AllocateException",
    "CommitRequest",
    "CommitResponse",
    "CommitException",
    "FetchRequest",
    "FetchResponse",
    "FetchException",
    "InitializeRequest",
    "InitializeResponse",
    "ReadSegmentRequest",
    "ReadSegmentResponse",
    "ReadSegmentException",
    "RMemInfoRequest",
    "RMemInfoResponse",
    "StageMessageRequest",
    "StageMessageResponse",
    "StageMessageException",
    "StageOffsetRequest",
    "StageOffsetResponse",
    "StageOffsetException",
    "WriteSegmentRequest",
    "WriteSegmentResponse",
    "WriteSegmentException",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_WriteSegmentException)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<Rembrandt::Protocol::AllocateRequest> {
  static const Message enum_value = Message_AllocateRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::AllocateResponse> {
  static const Message enum_value = Message_AllocateResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::AllocateException> {
  static const Message enum_value = Message_AllocateException;
};

template<> struct MessageTraits<Rembrandt::Protocol::CommitRequest> {
  static const Message enum_value = Message_CommitRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::CommitResponse> {
  static const Message enum_value = Message_CommitResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::CommitException> {
  static const Message enum_value = Message_CommitException;
};

template<> struct MessageTraits<Rembrandt::Protocol::FetchRequest> {
  static const Message enum_value = Message_FetchRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::FetchResponse> {
  static const Message enum_value = Message_FetchResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::FetchException> {
  static const Message enum_value = Message_FetchException;
};

template<> struct MessageTraits<Rembrandt::Protocol::InitializeRequest> {
  static const Message enum_value = Message_InitializeRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::InitializeResponse> {
  static const Message enum_value = Message_InitializeResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::ReadSegmentRequest> {
  static const Message enum_value = Message_ReadSegmentRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::ReadSegmentResponse> {
  static const Message enum_value = Message_ReadSegmentResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::ReadSegmentException> {
  static const Message enum_value = Message_ReadSegmentException;
};

template<> struct MessageTraits<Rembrandt::Protocol::RMemInfoRequest> {
  static const Message enum_value = Message_RMemInfoRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::RMemInfoResponse> {
  static const Message enum_value = Message_RMemInfoResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageMessageRequest> {
  static const Message enum_value = Message_StageMessageRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageMessageResponse> {
  static const Message enum_value = Message_StageMessageResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageMessageException> {
  static const Message enum_value = Message_StageMessageException;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageOffsetRequest> {
  static const Message enum_value = Message_StageOffsetRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageOffsetResponse> {
  static const Message enum_value = Message_StageOffsetResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::StageOffsetException> {
  static const Message enum_value = Message_StageOffsetException;
};

template<> struct MessageTraits<Rembrandt::Protocol::WriteSegmentRequest> {
  static const Message enum_value = Message_WriteSegmentRequest;
};

template<> struct MessageTraits<Rembrandt::Protocol::WriteSegmentResponse> {
  static const Message enum_value = Message_WriteSegmentResponse;
};

template<> struct MessageTraits<Rembrandt::Protocol::WriteSegmentException> {
  static const Message enum_value = Message_WriteSegmentException;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct BaseMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BaseMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_ID = 4,
    VT_CONTENT_TYPE = 6,
    VT_CONTENT = 8
  };
  uint64_t message_id() const {
    return GetField<uint64_t>(VT_MESSAGE_ID, 0);
  }
  Rembrandt::Protocol::Message content_type() const {
    return static_cast<Rembrandt::Protocol::Message>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const Rembrandt::Protocol::AllocateRequest *content_as_AllocateRequest() const {
    return content_type() == Rembrandt::Protocol::Message_AllocateRequest ? static_cast<const Rembrandt::Protocol::AllocateRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::AllocateResponse *content_as_AllocateResponse() const {
    return content_type() == Rembrandt::Protocol::Message_AllocateResponse ? static_cast<const Rembrandt::Protocol::AllocateResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::AllocateException *content_as_AllocateException() const {
    return content_type() == Rembrandt::Protocol::Message_AllocateException ? static_cast<const Rembrandt::Protocol::AllocateException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::CommitRequest *content_as_CommitRequest() const {
    return content_type() == Rembrandt::Protocol::Message_CommitRequest ? static_cast<const Rembrandt::Protocol::CommitRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::CommitResponse *content_as_CommitResponse() const {
    return content_type() == Rembrandt::Protocol::Message_CommitResponse ? static_cast<const Rembrandt::Protocol::CommitResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::CommitException *content_as_CommitException() const {
    return content_type() == Rembrandt::Protocol::Message_CommitException ? static_cast<const Rembrandt::Protocol::CommitException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::FetchRequest *content_as_FetchRequest() const {
    return content_type() == Rembrandt::Protocol::Message_FetchRequest ? static_cast<const Rembrandt::Protocol::FetchRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::FetchResponse *content_as_FetchResponse() const {
    return content_type() == Rembrandt::Protocol::Message_FetchResponse ? static_cast<const Rembrandt::Protocol::FetchResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::FetchException *content_as_FetchException() const {
    return content_type() == Rembrandt::Protocol::Message_FetchException ? static_cast<const Rembrandt::Protocol::FetchException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::InitializeRequest *content_as_InitializeRequest() const {
    return content_type() == Rembrandt::Protocol::Message_InitializeRequest ? static_cast<const Rembrandt::Protocol::InitializeRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::InitializeResponse *content_as_InitializeResponse() const {
    return content_type() == Rembrandt::Protocol::Message_InitializeResponse ? static_cast<const Rembrandt::Protocol::InitializeResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::ReadSegmentRequest *content_as_ReadSegmentRequest() const {
    return content_type() == Rembrandt::Protocol::Message_ReadSegmentRequest ? static_cast<const Rembrandt::Protocol::ReadSegmentRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::ReadSegmentResponse *content_as_ReadSegmentResponse() const {
    return content_type() == Rembrandt::Protocol::Message_ReadSegmentResponse ? static_cast<const Rembrandt::Protocol::ReadSegmentResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::ReadSegmentException *content_as_ReadSegmentException() const {
    return content_type() == Rembrandt::Protocol::Message_ReadSegmentException ? static_cast<const Rembrandt::Protocol::ReadSegmentException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::RMemInfoRequest *content_as_RMemInfoRequest() const {
    return content_type() == Rembrandt::Protocol::Message_RMemInfoRequest ? static_cast<const Rembrandt::Protocol::RMemInfoRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::RMemInfoResponse *content_as_RMemInfoResponse() const {
    return content_type() == Rembrandt::Protocol::Message_RMemInfoResponse ? static_cast<const Rembrandt::Protocol::RMemInfoResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageMessageRequest *content_as_StageMessageRequest() const {
    return content_type() == Rembrandt::Protocol::Message_StageMessageRequest ? static_cast<const Rembrandt::Protocol::StageMessageRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageMessageResponse *content_as_StageMessageResponse() const {
    return content_type() == Rembrandt::Protocol::Message_StageMessageResponse ? static_cast<const Rembrandt::Protocol::StageMessageResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageMessageException *content_as_StageMessageException() const {
    return content_type() == Rembrandt::Protocol::Message_StageMessageException ? static_cast<const Rembrandt::Protocol::StageMessageException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageOffsetRequest *content_as_StageOffsetRequest() const {
    return content_type() == Rembrandt::Protocol::Message_StageOffsetRequest ? static_cast<const Rembrandt::Protocol::StageOffsetRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageOffsetResponse *content_as_StageOffsetResponse() const {
    return content_type() == Rembrandt::Protocol::Message_StageOffsetResponse ? static_cast<const Rembrandt::Protocol::StageOffsetResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::StageOffsetException *content_as_StageOffsetException() const {
    return content_type() == Rembrandt::Protocol::Message_StageOffsetException ? static_cast<const Rembrandt::Protocol::StageOffsetException *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::WriteSegmentRequest *content_as_WriteSegmentRequest() const {
    return content_type() == Rembrandt::Protocol::Message_WriteSegmentRequest ? static_cast<const Rembrandt::Protocol::WriteSegmentRequest *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::WriteSegmentResponse *content_as_WriteSegmentResponse() const {
    return content_type() == Rembrandt::Protocol::Message_WriteSegmentResponse ? static_cast<const Rembrandt::Protocol::WriteSegmentResponse *>(content()) : nullptr;
  }
  const Rembrandt::Protocol::WriteSegmentException *content_as_WriteSegmentException() const {
    return content_type() == Rembrandt::Protocol::Message_WriteSegmentException ? static_cast<const Rembrandt::Protocol::WriteSegmentException *>(content()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_ID) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyMessage(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Rembrandt::Protocol::AllocateRequest *BaseMessage::content_as<Rembrandt::Protocol::AllocateRequest>() const {
  return content_as_AllocateRequest();
}

template<> inline const Rembrandt::Protocol::AllocateResponse *BaseMessage::content_as<Rembrandt::Protocol::AllocateResponse>() const {
  return content_as_AllocateResponse();
}

template<> inline const Rembrandt::Protocol::AllocateException *BaseMessage::content_as<Rembrandt::Protocol::AllocateException>() const {
  return content_as_AllocateException();
}

template<> inline const Rembrandt::Protocol::CommitRequest *BaseMessage::content_as<Rembrandt::Protocol::CommitRequest>() const {
  return content_as_CommitRequest();
}

template<> inline const Rembrandt::Protocol::CommitResponse *BaseMessage::content_as<Rembrandt::Protocol::CommitResponse>() const {
  return content_as_CommitResponse();
}

template<> inline const Rembrandt::Protocol::CommitException *BaseMessage::content_as<Rembrandt::Protocol::CommitException>() const {
  return content_as_CommitException();
}

template<> inline const Rembrandt::Protocol::FetchRequest *BaseMessage::content_as<Rembrandt::Protocol::FetchRequest>() const {
  return content_as_FetchRequest();
}

template<> inline const Rembrandt::Protocol::FetchResponse *BaseMessage::content_as<Rembrandt::Protocol::FetchResponse>() const {
  return content_as_FetchResponse();
}

template<> inline const Rembrandt::Protocol::FetchException *BaseMessage::content_as<Rembrandt::Protocol::FetchException>() const {
  return content_as_FetchException();
}

template<> inline const Rembrandt::Protocol::InitializeRequest *BaseMessage::content_as<Rembrandt::Protocol::InitializeRequest>() const {
  return content_as_InitializeRequest();
}

template<> inline const Rembrandt::Protocol::InitializeResponse *BaseMessage::content_as<Rembrandt::Protocol::InitializeResponse>() const {
  return content_as_InitializeResponse();
}

template<> inline const Rembrandt::Protocol::ReadSegmentRequest *BaseMessage::content_as<Rembrandt::Protocol::ReadSegmentRequest>() const {
  return content_as_ReadSegmentRequest();
}

template<> inline const Rembrandt::Protocol::ReadSegmentResponse *BaseMessage::content_as<Rembrandt::Protocol::ReadSegmentResponse>() const {
  return content_as_ReadSegmentResponse();
}

template<> inline const Rembrandt::Protocol::ReadSegmentException *BaseMessage::content_as<Rembrandt::Protocol::ReadSegmentException>() const {
  return content_as_ReadSegmentException();
}

template<> inline const Rembrandt::Protocol::RMemInfoRequest *BaseMessage::content_as<Rembrandt::Protocol::RMemInfoRequest>() const {
  return content_as_RMemInfoRequest();
}

template<> inline const Rembrandt::Protocol::RMemInfoResponse *BaseMessage::content_as<Rembrandt::Protocol::RMemInfoResponse>() const {
  return content_as_RMemInfoResponse();
}

template<> inline const Rembrandt::Protocol::StageMessageRequest *BaseMessage::content_as<Rembrandt::Protocol::StageMessageRequest>() const {
  return content_as_StageMessageRequest();
}

template<> inline const Rembrandt::Protocol::StageMessageResponse *BaseMessage::content_as<Rembrandt::Protocol::StageMessageResponse>() const {
  return content_as_StageMessageResponse();
}

template<> inline const Rembrandt::Protocol::StageMessageException *BaseMessage::content_as<Rembrandt::Protocol::StageMessageException>() const {
  return content_as_StageMessageException();
}

template<> inline const Rembrandt::Protocol::StageOffsetRequest *BaseMessage::content_as<Rembrandt::Protocol::StageOffsetRequest>() const {
  return content_as_StageOffsetRequest();
}

template<> inline const Rembrandt::Protocol::StageOffsetResponse *BaseMessage::content_as<Rembrandt::Protocol::StageOffsetResponse>() const {
  return content_as_StageOffsetResponse();
}

template<> inline const Rembrandt::Protocol::StageOffsetException *BaseMessage::content_as<Rembrandt::Protocol::StageOffsetException>() const {
  return content_as_StageOffsetException();
}

template<> inline const Rembrandt::Protocol::WriteSegmentRequest *BaseMessage::content_as<Rembrandt::Protocol::WriteSegmentRequest>() const {
  return content_as_WriteSegmentRequest();
}

template<> inline const Rembrandt::Protocol::WriteSegmentResponse *BaseMessage::content_as<Rembrandt::Protocol::WriteSegmentResponse>() const {
  return content_as_WriteSegmentResponse();
}

template<> inline const Rembrandt::Protocol::WriteSegmentException *BaseMessage::content_as<Rembrandt::Protocol::WriteSegmentException>() const {
  return content_as_WriteSegmentException();
}

struct BaseMessageBuilder {
  typedef BaseMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_id(uint64_t message_id) {
    fbb_.AddElement<uint64_t>(BaseMessage::VT_MESSAGE_ID, message_id, 0);
  }
  void add_content_type(Rembrandt::Protocol::Message content_type) {
    fbb_.AddElement<uint8_t>(BaseMessage::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(BaseMessage::VT_CONTENT, content);
  }
  explicit BaseMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaseMessageBuilder &operator=(const BaseMessageBuilder &);
  flatbuffers::Offset<BaseMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaseMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<BaseMessage> CreateBaseMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t message_id = 0,
    Rembrandt::Protocol::Message content_type = Rembrandt::Protocol::Message_NONE,
    flatbuffers::Offset<void> content = 0) {
  BaseMessageBuilder builder_(_fbb);
  builder_.add_message_id(message_id);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

struct AllocateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           verifier.EndTable();
  }
};

struct AllocateRequestBuilder {
  typedef AllocateRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(AllocateRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(AllocateRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(AllocateRequest::VT_SEGMENT_ID, segment_id, 0);
  }
  explicit AllocateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocateRequestBuilder &operator=(const AllocateRequestBuilder &);
  flatbuffers::Offset<AllocateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateRequest> CreateAllocateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0) {
  AllocateRequestBuilder builder_(_fbb);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct AllocateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_OFFSET = 6
  };
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct AllocateResponseBuilder {
  typedef AllocateResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(AllocateResponse::VT_SIZE, size, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(AllocateResponse::VT_OFFSET, offset, 0);
  }
  explicit AllocateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocateResponseBuilder &operator=(const AllocateResponseBuilder &);
  flatbuffers::Offset<AllocateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateResponse> CreateAllocateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t size = 0,
    uint64_t offset = 0) {
  AllocateResponseBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_size(size);
  return builder_.Finish();
}

struct AllocateException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllocateExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct AllocateExceptionBuilder {
  typedef AllocateException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(AllocateException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(AllocateException::VT_ERROR_MESSAGE, error_message);
  }
  explicit AllocateExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocateExceptionBuilder &operator=(const AllocateExceptionBuilder &);
  flatbuffers::Offset<AllocateException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllocateException>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocateException> CreateAllocateException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  AllocateExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<AllocateException> CreateAllocateExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateAllocateException(
      _fbb,
      error_code,
      error_message__);
}

struct StageMessageRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageMessageRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_MESSAGE_SIZE = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint64_t message_size() const {
    return GetField<uint64_t>(VT_MESSAGE_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_SIZE) &&
           verifier.EndTable();
  }
};

struct StageMessageRequestBuilder {
  typedef StageMessageRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(StageMessageRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(StageMessageRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_message_size(uint64_t message_size) {
    fbb_.AddElement<uint64_t>(StageMessageRequest::VT_MESSAGE_SIZE, message_size, 0);
  }
  explicit StageMessageRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageMessageRequestBuilder &operator=(const StageMessageRequestBuilder &);
  flatbuffers::Offset<StageMessageRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageMessageRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageMessageRequest> CreateStageMessageRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint64_t message_size = 0) {
  StageMessageRequestBuilder builder_(_fbb);
  builder_.add_message_size(message_size);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct StageMessageResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageMessageResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGICAL_OFFSET = 4,
    VT_REMOTE_LOCATION = 6
  };
  uint64_t logical_offset() const {
    return GetField<uint64_t>(VT_LOGICAL_OFFSET, 0);
  }
  uint64_t remote_location() const {
    return GetField<uint64_t>(VT_REMOTE_LOCATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LOGICAL_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_REMOTE_LOCATION) &&
           verifier.EndTable();
  }
};

struct StageMessageResponseBuilder {
  typedef StageMessageResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logical_offset(uint64_t logical_offset) {
    fbb_.AddElement<uint64_t>(StageMessageResponse::VT_LOGICAL_OFFSET, logical_offset, 0);
  }
  void add_remote_location(uint64_t remote_location) {
    fbb_.AddElement<uint64_t>(StageMessageResponse::VT_REMOTE_LOCATION, remote_location, 0);
  }
  explicit StageMessageResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageMessageResponseBuilder &operator=(const StageMessageResponseBuilder &);
  flatbuffers::Offset<StageMessageResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageMessageResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageMessageResponse> CreateStageMessageResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t logical_offset = 0,
    uint64_t remote_location = 0) {
  StageMessageResponseBuilder builder_(_fbb);
  builder_.add_remote_location(remote_location);
  builder_.add_logical_offset(logical_offset);
  return builder_.Finish();
}

struct StageMessageException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageMessageExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct StageMessageExceptionBuilder {
  typedef StageMessageException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(StageMessageException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(StageMessageException::VT_ERROR_MESSAGE, error_message);
  }
  explicit StageMessageExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageMessageExceptionBuilder &operator=(const StageMessageExceptionBuilder &);
  flatbuffers::Offset<StageMessageException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageMessageException>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageMessageException> CreateStageMessageException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  StageMessageExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<StageMessageException> CreateStageMessageExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateStageMessageException(
      _fbb,
      error_code,
      error_message__);
}

struct StageOffsetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageOffsetRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8,
    VT_OFFSET = 10
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct StageOffsetRequestBuilder {
  typedef StageOffsetRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(StageOffsetRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(StageOffsetRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(StageOffsetRequest::VT_SEGMENT_ID, segment_id, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(StageOffsetRequest::VT_OFFSET, offset, 0);
  }
  explicit StageOffsetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageOffsetRequestBuilder &operator=(const StageOffsetRequestBuilder &);
  flatbuffers::Offset<StageOffsetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageOffsetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageOffsetRequest> CreateStageOffsetRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0,
    uint64_t offset = 0) {
  StageOffsetRequestBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct StageOffsetResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageOffsetResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StageOffsetResponseBuilder {
  typedef StageOffsetResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StageOffsetResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageOffsetResponseBuilder &operator=(const StageOffsetResponseBuilder &);
  flatbuffers::Offset<StageOffsetResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageOffsetResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageOffsetResponse> CreateStageOffsetResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StageOffsetResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct StageOffsetException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StageOffsetExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct StageOffsetExceptionBuilder {
  typedef StageOffsetException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(StageOffsetException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(StageOffsetException::VT_ERROR_MESSAGE, error_message);
  }
  explicit StageOffsetExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StageOffsetExceptionBuilder &operator=(const StageOffsetExceptionBuilder &);
  flatbuffers::Offset<StageOffsetException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StageOffsetException>(end);
    return o;
  }
};

inline flatbuffers::Offset<StageOffsetException> CreateStageOffsetException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  StageOffsetExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<StageOffsetException> CreateStageOffsetExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateStageOffsetException(
      _fbb,
      error_code,
      error_message__);
}

struct CommitRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommitRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_LOGICAL_OFFSET = 8,
    VT_MESSAGE_SIZE = 10
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint64_t logical_offset() const {
    return GetField<uint64_t>(VT_LOGICAL_OFFSET, 0);
  }
  uint64_t message_size() const {
    return GetField<uint64_t>(VT_MESSAGE_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint64_t>(verifier, VT_LOGICAL_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGE_SIZE) &&
           verifier.EndTable();
  }
};

struct CommitRequestBuilder {
  typedef CommitRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(CommitRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(CommitRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_logical_offset(uint64_t logical_offset) {
    fbb_.AddElement<uint64_t>(CommitRequest::VT_LOGICAL_OFFSET, logical_offset, 0);
  }
  void add_message_size(uint64_t message_size) {
    fbb_.AddElement<uint64_t>(CommitRequest::VT_MESSAGE_SIZE, message_size, 0);
  }
  explicit CommitRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitRequestBuilder &operator=(const CommitRequestBuilder &);
  flatbuffers::Offset<CommitRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommitRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommitRequest> CreateCommitRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint64_t logical_offset = 0,
    uint64_t message_size = 0) {
  CommitRequestBuilder builder_(_fbb);
  builder_.add_message_size(message_size);
  builder_.add_logical_offset(logical_offset);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct CommitResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommitResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4
  };
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct CommitResponseBuilder {
  typedef CommitResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(CommitResponse::VT_OFFSET, offset, 0);
  }
  explicit CommitResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitResponseBuilder &operator=(const CommitResponseBuilder &);
  flatbuffers::Offset<CommitResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommitResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommitResponse> CreateCommitResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t offset = 0) {
  CommitResponseBuilder builder_(_fbb);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct CommitException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommitExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct CommitExceptionBuilder {
  typedef CommitException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(CommitException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(CommitException::VT_ERROR_MESSAGE, error_message);
  }
  explicit CommitExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommitExceptionBuilder &operator=(const CommitExceptionBuilder &);
  flatbuffers::Offset<CommitException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommitException>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommitException> CreateCommitException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  CommitExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommitException> CreateCommitExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateCommitException(
      _fbb,
      error_code,
      error_message__);
}

struct FetchRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           verifier.EndTable();
  }
};

struct FetchRequestBuilder {
  typedef FetchRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(FetchRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(FetchRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(FetchRequest::VT_SEGMENT_ID, segment_id, 0);
  }
  explicit FetchRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchRequestBuilder &operator=(const FetchRequestBuilder &);
  flatbuffers::Offset<FetchRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FetchRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FetchRequest> CreateFetchRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0) {
  FetchRequestBuilder builder_(_fbb);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  return builder_.Finish();
}

struct FetchResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_OFFSET = 4,
    VT_COMMIT_OFFSET = 6,
    VT_IS_COMMITTABLE = 8
  };
  uint64_t start_offset() const {
    return GetField<uint64_t>(VT_START_OFFSET, 0);
  }
  uint64_t commit_offset() const {
    return GetField<uint64_t>(VT_COMMIT_OFFSET, 0);
  }
  bool is_committable() const {
    return GetField<uint8_t>(VT_IS_COMMITTABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_START_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_COMMIT_OFFSET) &&
           VerifyField<uint8_t>(verifier, VT_IS_COMMITTABLE) &&
           verifier.EndTable();
  }
};

struct FetchResponseBuilder {
  typedef FetchResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_offset(uint64_t start_offset) {
    fbb_.AddElement<uint64_t>(FetchResponse::VT_START_OFFSET, start_offset, 0);
  }
  void add_commit_offset(uint64_t commit_offset) {
    fbb_.AddElement<uint64_t>(FetchResponse::VT_COMMIT_OFFSET, commit_offset, 0);
  }
  void add_is_committable(bool is_committable) {
    fbb_.AddElement<uint8_t>(FetchResponse::VT_IS_COMMITTABLE, static_cast<uint8_t>(is_committable), 0);
  }
  explicit FetchResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchResponseBuilder &operator=(const FetchResponseBuilder &);
  flatbuffers::Offset<FetchResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FetchResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<FetchResponse> CreateFetchResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start_offset = 0,
    uint64_t commit_offset = 0,
    bool is_committable = false) {
  FetchResponseBuilder builder_(_fbb);
  builder_.add_commit_offset(commit_offset);
  builder_.add_start_offset(start_offset);
  builder_.add_is_committable(is_committable);
  return builder_.Finish();
}

struct FetchException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FetchExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  uint16_t error_message() const {
    return GetField<uint16_t>(VT_ERROR_MESSAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_MESSAGE) &&
           verifier.EndTable();
  }
};

struct FetchExceptionBuilder {
  typedef FetchException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(FetchException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(uint16_t error_message) {
    fbb_.AddElement<uint16_t>(FetchException::VT_ERROR_MESSAGE, error_message, 0);
  }
  explicit FetchExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FetchExceptionBuilder &operator=(const FetchExceptionBuilder &);
  flatbuffers::Offset<FetchException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FetchException>(end);
    return o;
  }
};

inline flatbuffers::Offset<FetchException> CreateFetchException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    uint16_t error_message = 0) {
  FetchExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

struct InitializeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitializeRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InitializeRequestBuilder {
  typedef InitializeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InitializeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitializeRequestBuilder &operator=(const InitializeRequestBuilder &);
  flatbuffers::Offset<InitializeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InitializeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InitializeRequest> CreateInitializeRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InitializeRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct InitializeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitializeResponseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InitializeResponseBuilder {
  typedef InitializeResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InitializeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InitializeResponseBuilder &operator=(const InitializeResponseBuilder &);
  flatbuffers::Offset<InitializeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InitializeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InitializeResponse> CreateInitializeResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InitializeResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReadSegmentRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReadSegmentRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8,
    VT_NEXT = 10
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  bool next() const {
    return GetField<uint8_t>(VT_NEXT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           VerifyField<uint8_t>(verifier, VT_NEXT) &&
           verifier.EndTable();
  }
};

struct ReadSegmentRequestBuilder {
  typedef ReadSegmentRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(ReadSegmentRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(ReadSegmentRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(ReadSegmentRequest::VT_SEGMENT_ID, segment_id, 0);
  }
  void add_next(bool next) {
    fbb_.AddElement<uint8_t>(ReadSegmentRequest::VT_NEXT, static_cast<uint8_t>(next), 0);
  }
  explicit ReadSegmentRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadSegmentRequestBuilder &operator=(const ReadSegmentRequestBuilder &);
  flatbuffers::Offset<ReadSegmentRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadSegmentRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadSegmentRequest> CreateReadSegmentRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0,
    bool next = false) {
  ReadSegmentRequestBuilder builder_(_fbb);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  builder_.add_next(next);
  return builder_.Finish();
}

struct ReadSegmentResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReadSegmentResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8,
    VT_START_OFFSET = 10,
    VT_COMMIT_OFFSET = 12,
    VT_IS_COMMITTABLE = 14
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  uint64_t start_offset() const {
    return GetField<uint64_t>(VT_START_OFFSET, 0);
  }
  uint64_t commit_offset() const {
    return GetField<uint64_t>(VT_COMMIT_OFFSET, 0);
  }
  bool is_committable() const {
    return GetField<uint8_t>(VT_IS_COMMITTABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           VerifyField<uint64_t>(verifier, VT_START_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_COMMIT_OFFSET) &&
           VerifyField<uint8_t>(verifier, VT_IS_COMMITTABLE) &&
           verifier.EndTable();
  }
};

struct ReadSegmentResponseBuilder {
  typedef ReadSegmentResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(ReadSegmentResponse::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(ReadSegmentResponse::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(ReadSegmentResponse::VT_SEGMENT_ID, segment_id, 0);
  }
  void add_start_offset(uint64_t start_offset) {
    fbb_.AddElement<uint64_t>(ReadSegmentResponse::VT_START_OFFSET, start_offset, 0);
  }
  void add_commit_offset(uint64_t commit_offset) {
    fbb_.AddElement<uint64_t>(ReadSegmentResponse::VT_COMMIT_OFFSET, commit_offset, 0);
  }
  void add_is_committable(bool is_committable) {
    fbb_.AddElement<uint8_t>(ReadSegmentResponse::VT_IS_COMMITTABLE, static_cast<uint8_t>(is_committable), 0);
  }
  explicit ReadSegmentResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadSegmentResponseBuilder &operator=(const ReadSegmentResponseBuilder &);
  flatbuffers::Offset<ReadSegmentResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadSegmentResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadSegmentResponse> CreateReadSegmentResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0,
    uint64_t start_offset = 0,
    uint64_t commit_offset = 0,
    bool is_committable = false) {
  ReadSegmentResponseBuilder builder_(_fbb);
  builder_.add_commit_offset(commit_offset);
  builder_.add_start_offset(start_offset);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  builder_.add_is_committable(is_committable);
  return builder_.Finish();
}

struct ReadSegmentException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReadSegmentExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct ReadSegmentExceptionBuilder {
  typedef ReadSegmentException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(ReadSegmentException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(ReadSegmentException::VT_ERROR_MESSAGE, error_message);
  }
  explicit ReadSegmentExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadSegmentExceptionBuilder &operator=(const ReadSegmentExceptionBuilder &);
  flatbuffers::Offset<ReadSegmentException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadSegmentException>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadSegmentException> CreateReadSegmentException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  ReadSegmentExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReadSegmentException> CreateReadSegmentExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateReadSegmentException(
      _fbb,
      error_code,
      error_message__);
}

struct RMemInfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RMemInfoRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RMemInfoRequestBuilder {
  typedef RMemInfoRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RMemInfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RMemInfoRequestBuilder &operator=(const RMemInfoRequestBuilder &);
  flatbuffers::Offset<RMemInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RMemInfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RMemInfoRequest> CreateRMemInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RMemInfoRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RMemInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RMemInfoResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REMOTE_ADDRESS = 4,
    VT_REMOTE_KEY = 6
  };
  uint64_t remote_address() const {
    return GetField<uint64_t>(VT_REMOTE_ADDRESS, 0);
  }
  const flatbuffers::String *remote_key() const {
    return GetPointer<const flatbuffers::String *>(VT_REMOTE_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REMOTE_ADDRESS) &&
           VerifyOffset(verifier, VT_REMOTE_KEY) &&
           verifier.VerifyString(remote_key()) &&
           verifier.EndTable();
  }
};

struct RMemInfoResponseBuilder {
  typedef RMemInfoResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remote_address(uint64_t remote_address) {
    fbb_.AddElement<uint64_t>(RMemInfoResponse::VT_REMOTE_ADDRESS, remote_address, 0);
  }
  void add_remote_key(flatbuffers::Offset<flatbuffers::String> remote_key) {
    fbb_.AddOffset(RMemInfoResponse::VT_REMOTE_KEY, remote_key);
  }
  explicit RMemInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RMemInfoResponseBuilder &operator=(const RMemInfoResponseBuilder &);
  flatbuffers::Offset<RMemInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RMemInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<RMemInfoResponse> CreateRMemInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t remote_address = 0,
    flatbuffers::Offset<flatbuffers::String> remote_key = 0) {
  RMemInfoResponseBuilder builder_(_fbb);
  builder_.add_remote_address(remote_address);
  builder_.add_remote_key(remote_key);
  return builder_.Finish();
}

inline flatbuffers::Offset<RMemInfoResponse> CreateRMemInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t remote_address = 0,
    const char *remote_key = nullptr) {
  auto remote_key__ = remote_key ? _fbb.CreateString(remote_key) : 0;
  return Rembrandt::Protocol::CreateRMemInfoResponse(
      _fbb,
      remote_address,
      remote_key__);
}

struct WriteSegmentRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WriteSegmentRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8,
    VT_NEXT = 10
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  bool next() const {
    return GetField<uint8_t>(VT_NEXT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           VerifyField<uint8_t>(verifier, VT_NEXT) &&
           verifier.EndTable();
  }
};

struct WriteSegmentRequestBuilder {
  typedef WriteSegmentRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(WriteSegmentRequest::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(WriteSegmentRequest::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(WriteSegmentRequest::VT_SEGMENT_ID, segment_id, 0);
  }
  void add_next(bool next) {
    fbb_.AddElement<uint8_t>(WriteSegmentRequest::VT_NEXT, static_cast<uint8_t>(next), 0);
  }
  explicit WriteSegmentRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteSegmentRequestBuilder &operator=(const WriteSegmentRequestBuilder &);
  flatbuffers::Offset<WriteSegmentRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WriteSegmentRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteSegmentRequest> CreateWriteSegmentRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0,
    bool next = false) {
  WriteSegmentRequestBuilder builder_(_fbb);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  builder_.add_next(next);
  return builder_.Finish();
}

struct WriteSegmentResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WriteSegmentResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOPIC_ID = 4,
    VT_PARTITION_ID = 6,
    VT_SEGMENT_ID = 8,
    VT_START_OFFSET = 10,
    VT_WRITE_OFFSET = 12,
    VT_SIZE = 14,
    VT_IS_WRITEABLE = 16
  };
  uint32_t topic_id() const {
    return GetField<uint32_t>(VT_TOPIC_ID, 0);
  }
  uint32_t partition_id() const {
    return GetField<uint32_t>(VT_PARTITION_ID, 0);
  }
  uint32_t segment_id() const {
    return GetField<uint32_t>(VT_SEGMENT_ID, 0);
  }
  uint64_t start_offset() const {
    return GetField<uint64_t>(VT_START_OFFSET, 0);
  }
  uint64_t write_offset() const {
    return GetField<uint64_t>(VT_WRITE_OFFSET, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool is_writeable() const {
    return GetField<uint8_t>(VT_IS_WRITEABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOPIC_ID) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_ID) &&
           VerifyField<uint32_t>(verifier, VT_SEGMENT_ID) &&
           VerifyField<uint64_t>(verifier, VT_START_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_WRITE_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_IS_WRITEABLE) &&
           verifier.EndTable();
  }
};

struct WriteSegmentResponseBuilder {
  typedef WriteSegmentResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic_id(uint32_t topic_id) {
    fbb_.AddElement<uint32_t>(WriteSegmentResponse::VT_TOPIC_ID, topic_id, 0);
  }
  void add_partition_id(uint32_t partition_id) {
    fbb_.AddElement<uint32_t>(WriteSegmentResponse::VT_PARTITION_ID, partition_id, 0);
  }
  void add_segment_id(uint32_t segment_id) {
    fbb_.AddElement<uint32_t>(WriteSegmentResponse::VT_SEGMENT_ID, segment_id, 0);
  }
  void add_start_offset(uint64_t start_offset) {
    fbb_.AddElement<uint64_t>(WriteSegmentResponse::VT_START_OFFSET, start_offset, 0);
  }
  void add_write_offset(uint64_t write_offset) {
    fbb_.AddElement<uint64_t>(WriteSegmentResponse::VT_WRITE_OFFSET, write_offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(WriteSegmentResponse::VT_SIZE, size, 0);
  }
  void add_is_writeable(bool is_writeable) {
    fbb_.AddElement<uint8_t>(WriteSegmentResponse::VT_IS_WRITEABLE, static_cast<uint8_t>(is_writeable), 0);
  }
  explicit WriteSegmentResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteSegmentResponseBuilder &operator=(const WriteSegmentResponseBuilder &);
  flatbuffers::Offset<WriteSegmentResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WriteSegmentResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteSegmentResponse> CreateWriteSegmentResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t topic_id = 0,
    uint32_t partition_id = 0,
    uint32_t segment_id = 0,
    uint64_t start_offset = 0,
    uint64_t write_offset = 0,
    uint64_t size = 0,
    bool is_writeable = false) {
  WriteSegmentResponseBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_write_offset(write_offset);
  builder_.add_start_offset(start_offset);
  builder_.add_segment_id(segment_id);
  builder_.add_partition_id(partition_id);
  builder_.add_topic_id(topic_id);
  builder_.add_is_writeable(is_writeable);
  return builder_.Finish();
}

struct WriteSegmentException FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WriteSegmentExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_ERROR_MESSAGE = 6
  };
  uint16_t error_code() const {
    return GetField<uint16_t>(VT_ERROR_CODE, 0);
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct WriteSegmentExceptionBuilder {
  typedef WriteSegmentException Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(uint16_t error_code) {
    fbb_.AddElement<uint16_t>(WriteSegmentException::VT_ERROR_CODE, error_code, 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(WriteSegmentException::VT_ERROR_MESSAGE, error_message);
  }
  explicit WriteSegmentExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteSegmentExceptionBuilder &operator=(const WriteSegmentExceptionBuilder &);
  flatbuffers::Offset<WriteSegmentException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WriteSegmentException>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteSegmentException> CreateWriteSegmentException(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  WriteSegmentExceptionBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<WriteSegmentException> CreateWriteSegmentExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t error_code = 0,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return Rembrandt::Protocol::CreateWriteSegmentException(
      _fbb,
      error_code,
      error_message__);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_AllocateRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::AllocateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AllocateResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::AllocateResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AllocateException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::AllocateException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CommitRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::CommitRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CommitResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::CommitResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CommitException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::CommitException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_FetchRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::FetchRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_FetchResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::FetchResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_FetchException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::FetchException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_InitializeRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::InitializeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_InitializeResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::InitializeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ReadSegmentRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::ReadSegmentRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ReadSegmentResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::ReadSegmentResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ReadSegmentException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::ReadSegmentException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_RMemInfoRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::RMemInfoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_RMemInfoResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::RMemInfoResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageMessageRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageMessageRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageMessageResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageMessageResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageMessageException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageMessageException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageOffsetRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageOffsetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageOffsetResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageOffsetResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StageOffsetException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::StageOffsetException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_WriteSegmentRequest: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::WriteSegmentRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_WriteSegmentResponse: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::WriteSegmentResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_WriteSegmentException: {
      auto ptr = reinterpret_cast<const Rembrandt::Protocol::WriteSegmentException *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Protocol
}  // namespace Rembrandt

#endif  // FLATBUFFERS_GENERATED_REMBRANDTPROTOCOL_REMBRANDT_PROTOCOL_H_

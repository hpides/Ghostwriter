// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: rembrandt_protocol.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 7000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e7c229bc0acb3fbb);
CAPNP_DECLARE_SCHEMA(dcda37b3dda619f3);
CAPNP_DECLARE_SCHEMA(ae101d9ee907b327);
CAPNP_DECLARE_SCHEMA(e66b30481f0fd9be);
CAPNP_DECLARE_SCHEMA(93897c1929c268f4);
CAPNP_DECLARE_SCHEMA(bd05fc1eab44a5ff);
CAPNP_DECLARE_SCHEMA(a5dee1ae383cc9c7);
CAPNP_DECLARE_SCHEMA(f079d42414bebd84);

}  // namespace schemas
}  // namespace capnp


struct Allocate {
  Allocate() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7c229bc0acb3fbb, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Allocated {
  Allocated() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dcda37b3dda619f3, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AllocateFailed {
  AllocateFailed() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ae101d9ee907b327, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Free {
  Free() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e66b30481f0fd9be, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Freed {
  Freed() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(93897c1929c268f4, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FreeFailed {
  FreeFailed() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd05fc1eab44a5ff, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Message {
  Message() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Message;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a5dee1ae383cc9c7, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Message::Message {
  Message() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    ALLOCATE,
    ALLOCATED,
    ALLOCATE_FAILED,
    FREE,
    FREED,
    FREE_FAILED,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f079d42414bebd84, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Allocate::Reader {
public:
  typedef Allocate Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId() const;

  inline  ::uint32_t getPartitionId() const;

  inline  ::uint32_t getSegmentId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Allocate::Builder {
public:
  typedef Allocate Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId();
  inline void setTopicId( ::uint32_t value);

  inline  ::uint32_t getPartitionId();
  inline void setPartitionId( ::uint32_t value);

  inline  ::uint32_t getSegmentId();
  inline void setSegmentId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Allocate::Pipeline {
public:
  typedef Allocate Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Allocated::Reader {
public:
  typedef Allocated Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId() const;

  inline  ::uint32_t getPartitionId() const;

  inline  ::uint32_t getSegmentId() const;

  inline  ::uint64_t getOffset() const;

  inline  ::uint64_t getSize() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Allocated::Builder {
public:
  typedef Allocated Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId();
  inline void setTopicId( ::uint32_t value);

  inline  ::uint32_t getPartitionId();
  inline void setPartitionId( ::uint32_t value);

  inline  ::uint32_t getSegmentId();
  inline void setSegmentId( ::uint32_t value);

  inline  ::uint64_t getOffset();
  inline void setOffset( ::uint64_t value);

  inline  ::uint64_t getSize();
  inline void setSize( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Allocated::Pipeline {
public:
  typedef Allocated Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AllocateFailed::Reader {
public:
  typedef AllocateFailed Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId() const;

  inline  ::uint32_t getPartitionId() const;

  inline  ::uint32_t getSegmentId() const;

  inline  ::uint16_t getErrorCode() const;

  inline bool hasErrorMessage() const;
  inline  ::capnp::Text::Reader getErrorMessage() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AllocateFailed::Builder {
public:
  typedef AllocateFailed Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId();
  inline void setTopicId( ::uint32_t value);

  inline  ::uint32_t getPartitionId();
  inline void setPartitionId( ::uint32_t value);

  inline  ::uint32_t getSegmentId();
  inline void setSegmentId( ::uint32_t value);

  inline  ::uint16_t getErrorCode();
  inline void setErrorCode( ::uint16_t value);

  inline bool hasErrorMessage();
  inline  ::capnp::Text::Builder getErrorMessage();
  inline void setErrorMessage( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initErrorMessage(unsigned int size);
  inline void adoptErrorMessage(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownErrorMessage();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AllocateFailed::Pipeline {
public:
  typedef AllocateFailed Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Free::Reader {
public:
  typedef Free Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId() const;

  inline  ::uint32_t getPartitionId() const;

  inline  ::uint32_t getSegmentId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Free::Builder {
public:
  typedef Free Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId();
  inline void setTopicId( ::uint32_t value);

  inline  ::uint32_t getPartitionId();
  inline void setPartitionId( ::uint32_t value);

  inline  ::uint32_t getSegmentId();
  inline void setSegmentId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Free::Pipeline {
public:
  typedef Free Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Freed::Reader {
public:
  typedef Freed Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId() const;

  inline  ::uint32_t getPartitionId() const;

  inline  ::uint32_t getSegmentId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Freed::Builder {
public:
  typedef Freed Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId();
  inline void setTopicId( ::uint32_t value);

  inline  ::uint32_t getPartitionId();
  inline void setPartitionId( ::uint32_t value);

  inline  ::uint32_t getSegmentId();
  inline void setSegmentId( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Freed::Pipeline {
public:
  typedef Freed Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FreeFailed::Reader {
public:
  typedef FreeFailed Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId() const;

  inline  ::uint32_t getPartitionId() const;

  inline  ::uint32_t getSegmentId() const;

  inline  ::uint16_t getErrorCode() const;

  inline bool hasErrorMessage() const;
  inline  ::capnp::Text::Reader getErrorMessage() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FreeFailed::Builder {
public:
  typedef FreeFailed Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getTopicId();
  inline void setTopicId( ::uint32_t value);

  inline  ::uint32_t getPartitionId();
  inline void setPartitionId( ::uint32_t value);

  inline  ::uint32_t getSegmentId();
  inline void setSegmentId( ::uint32_t value);

  inline  ::uint16_t getErrorCode();
  inline void setErrorCode( ::uint16_t value);

  inline bool hasErrorMessage();
  inline  ::capnp::Text::Builder getErrorMessage();
  inline void setErrorMessage( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initErrorMessage(unsigned int size);
  inline void adoptErrorMessage(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownErrorMessage();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FreeFailed::Pipeline {
public:
  typedef FreeFailed Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Message::Reader {
public:
  typedef Message Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Message::Reader getMessage() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Message::Builder {
public:
  typedef Message Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Message::Builder getMessage();
  inline typename Message::Builder initMessage();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Message::Pipeline {
public:
  typedef Message Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Message::Pipeline getMessage();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Message::Message::Reader {
public:
  typedef Message Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isAllocate() const;
  inline bool hasAllocate() const;
  inline  ::Allocate::Reader getAllocate() const;

  inline bool isAllocated() const;
  inline bool hasAllocated() const;
  inline  ::Allocated::Reader getAllocated() const;

  inline bool isAllocateFailed() const;
  inline bool hasAllocateFailed() const;
  inline  ::AllocateFailed::Reader getAllocateFailed() const;

  inline bool isFree() const;
  inline bool hasFree() const;
  inline  ::Free::Reader getFree() const;

  inline bool isFreed() const;
  inline bool hasFreed() const;
  inline  ::Freed::Reader getFreed() const;

  inline bool isFreeFailed() const;
  inline bool hasFreeFailed() const;
  inline  ::FreeFailed::Reader getFreeFailed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Message::Message::Builder {
public:
  typedef Message Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isAllocate();
  inline bool hasAllocate();
  inline  ::Allocate::Builder getAllocate();
  inline void setAllocate( ::Allocate::Reader value);
  inline  ::Allocate::Builder initAllocate();
  inline void adoptAllocate(::capnp::Orphan< ::Allocate>&& value);
  inline ::capnp::Orphan< ::Allocate> disownAllocate();

  inline bool isAllocated();
  inline bool hasAllocated();
  inline  ::Allocated::Builder getAllocated();
  inline void setAllocated( ::Allocated::Reader value);
  inline  ::Allocated::Builder initAllocated();
  inline void adoptAllocated(::capnp::Orphan< ::Allocated>&& value);
  inline ::capnp::Orphan< ::Allocated> disownAllocated();

  inline bool isAllocateFailed();
  inline bool hasAllocateFailed();
  inline  ::AllocateFailed::Builder getAllocateFailed();
  inline void setAllocateFailed( ::AllocateFailed::Reader value);
  inline  ::AllocateFailed::Builder initAllocateFailed();
  inline void adoptAllocateFailed(::capnp::Orphan< ::AllocateFailed>&& value);
  inline ::capnp::Orphan< ::AllocateFailed> disownAllocateFailed();

  inline bool isFree();
  inline bool hasFree();
  inline  ::Free::Builder getFree();
  inline void setFree( ::Free::Reader value);
  inline  ::Free::Builder initFree();
  inline void adoptFree(::capnp::Orphan< ::Free>&& value);
  inline ::capnp::Orphan< ::Free> disownFree();

  inline bool isFreed();
  inline bool hasFreed();
  inline  ::Freed::Builder getFreed();
  inline void setFreed( ::Freed::Reader value);
  inline  ::Freed::Builder initFreed();
  inline void adoptFreed(::capnp::Orphan< ::Freed>&& value);
  inline ::capnp::Orphan< ::Freed> disownFreed();

  inline bool isFreeFailed();
  inline bool hasFreeFailed();
  inline  ::FreeFailed::Builder getFreeFailed();
  inline void setFreeFailed( ::FreeFailed::Reader value);
  inline  ::FreeFailed::Builder initFreeFailed();
  inline void adoptFreeFailed(::capnp::Orphan< ::FreeFailed>&& value);
  inline ::capnp::Orphan< ::FreeFailed> disownFreeFailed();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Message::Message::Pipeline {
public:
  typedef Message Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint32_t Allocate::Reader::getTopicId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Allocate::Builder::getTopicId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Allocate::Builder::setTopicId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Allocate::Reader::getPartitionId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Allocate::Builder::getPartitionId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Allocate::Builder::setPartitionId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Allocate::Reader::getSegmentId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Allocate::Builder::getSegmentId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Allocate::Builder::setSegmentId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Allocated::Reader::getTopicId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Allocated::Builder::getTopicId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Allocated::Builder::setTopicId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Allocated::Reader::getPartitionId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Allocated::Builder::getPartitionId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Allocated::Builder::setPartitionId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Allocated::Reader::getSegmentId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Allocated::Builder::getSegmentId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Allocated::Builder::setSegmentId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Allocated::Reader::getOffset() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Allocated::Builder::getOffset() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Allocated::Builder::setOffset( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Allocated::Reader::getSize() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Allocated::Builder::getSize() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Allocated::Builder::setSize( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t AllocateFailed::Reader::getTopicId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AllocateFailed::Builder::getTopicId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AllocateFailed::Builder::setTopicId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t AllocateFailed::Reader::getPartitionId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AllocateFailed::Builder::getPartitionId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void AllocateFailed::Builder::setPartitionId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t AllocateFailed::Reader::getSegmentId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t AllocateFailed::Builder::getSegmentId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void AllocateFailed::Builder::setSegmentId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t AllocateFailed::Reader::getErrorCode() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t AllocateFailed::Builder::getErrorCode() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void AllocateFailed::Builder::setErrorCode( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool AllocateFailed::Reader::hasErrorMessage() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AllocateFailed::Builder::hasErrorMessage() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AllocateFailed::Reader::getErrorMessage() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AllocateFailed::Builder::getErrorMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AllocateFailed::Builder::setErrorMessage( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AllocateFailed::Builder::initErrorMessage(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AllocateFailed::Builder::adoptErrorMessage(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AllocateFailed::Builder::disownErrorMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint32_t Free::Reader::getTopicId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Free::Builder::getTopicId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Free::Builder::setTopicId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Free::Reader::getPartitionId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Free::Builder::getPartitionId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Free::Builder::setPartitionId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Free::Reader::getSegmentId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Free::Builder::getSegmentId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Free::Builder::setSegmentId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Freed::Reader::getTopicId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Freed::Builder::getTopicId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Freed::Builder::setTopicId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Freed::Reader::getPartitionId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Freed::Builder::getPartitionId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Freed::Builder::setPartitionId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Freed::Reader::getSegmentId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Freed::Builder::getSegmentId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Freed::Builder::setSegmentId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t FreeFailed::Reader::getTopicId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FreeFailed::Builder::getTopicId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FreeFailed::Builder::setTopicId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t FreeFailed::Reader::getPartitionId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FreeFailed::Builder::getPartitionId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FreeFailed::Builder::setPartitionId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t FreeFailed::Reader::getSegmentId() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t FreeFailed::Builder::getSegmentId() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void FreeFailed::Builder::setSegmentId( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t FreeFailed::Reader::getErrorCode() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t FreeFailed::Builder::getErrorCode() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void FreeFailed::Builder::setErrorCode( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool FreeFailed::Reader::hasErrorMessage() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FreeFailed::Builder::hasErrorMessage() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader FreeFailed::Reader::getErrorMessage() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder FreeFailed::Builder::getErrorMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FreeFailed::Builder::setErrorMessage( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder FreeFailed::Builder::initErrorMessage(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FreeFailed::Builder::adoptErrorMessage(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> FreeFailed::Builder::disownErrorMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline typename Message::Message::Reader Message::Reader::getMessage() const {
  return typename Message::Message::Reader(_reader);
}
inline typename Message::Message::Builder Message::Builder::getMessage() {
  return typename Message::Message::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Message::Message::Pipeline Message::Pipeline::getMessage() {
  return typename Message::Message::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Message::Message::Builder Message::Builder::initMessage() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Message::Message::Builder(_builder);
}
inline  ::Message::Message::Which Message::Message::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::Message::Message::Which Message::Message::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Message::Message::Reader::isAllocate() const {
  return which() == Message::Message::ALLOCATE;
}
inline bool Message::Message::Builder::isAllocate() {
  return which() == Message::Message::ALLOCATE;
}
inline bool Message::Message::Reader::hasAllocate() const {
  if (which() != Message::Message::ALLOCATE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Message::Message::Builder::hasAllocate() {
  if (which() != Message::Message::ALLOCATE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Allocate::Reader Message::Message::Reader::getAllocate() const {
  KJ_IREQUIRE((which() == Message::Message::ALLOCATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Allocate>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Allocate::Builder Message::Message::Builder::getAllocate() {
  KJ_IREQUIRE((which() == Message::Message::ALLOCATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Allocate>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::setAllocate( ::Allocate::Reader value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::ALLOCATE);
  ::capnp::_::PointerHelpers< ::Allocate>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Allocate::Builder Message::Message::Builder::initAllocate() {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::ALLOCATE);
  return ::capnp::_::PointerHelpers< ::Allocate>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::adoptAllocate(
    ::capnp::Orphan< ::Allocate>&& value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::ALLOCATE);
  ::capnp::_::PointerHelpers< ::Allocate>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Allocate> Message::Message::Builder::disownAllocate() {
  KJ_IREQUIRE((which() == Message::Message::ALLOCATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Allocate>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Message::Message::Reader::isAllocated() const {
  return which() == Message::Message::ALLOCATED;
}
inline bool Message::Message::Builder::isAllocated() {
  return which() == Message::Message::ALLOCATED;
}
inline bool Message::Message::Reader::hasAllocated() const {
  if (which() != Message::Message::ALLOCATED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Message::Message::Builder::hasAllocated() {
  if (which() != Message::Message::ALLOCATED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Allocated::Reader Message::Message::Reader::getAllocated() const {
  KJ_IREQUIRE((which() == Message::Message::ALLOCATED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Allocated>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Allocated::Builder Message::Message::Builder::getAllocated() {
  KJ_IREQUIRE((which() == Message::Message::ALLOCATED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Allocated>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::setAllocated( ::Allocated::Reader value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::ALLOCATED);
  ::capnp::_::PointerHelpers< ::Allocated>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Allocated::Builder Message::Message::Builder::initAllocated() {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::ALLOCATED);
  return ::capnp::_::PointerHelpers< ::Allocated>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::adoptAllocated(
    ::capnp::Orphan< ::Allocated>&& value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::ALLOCATED);
  ::capnp::_::PointerHelpers< ::Allocated>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Allocated> Message::Message::Builder::disownAllocated() {
  KJ_IREQUIRE((which() == Message::Message::ALLOCATED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Allocated>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Message::Message::Reader::isAllocateFailed() const {
  return which() == Message::Message::ALLOCATE_FAILED;
}
inline bool Message::Message::Builder::isAllocateFailed() {
  return which() == Message::Message::ALLOCATE_FAILED;
}
inline bool Message::Message::Reader::hasAllocateFailed() const {
  if (which() != Message::Message::ALLOCATE_FAILED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Message::Message::Builder::hasAllocateFailed() {
  if (which() != Message::Message::ALLOCATE_FAILED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AllocateFailed::Reader Message::Message::Reader::getAllocateFailed() const {
  KJ_IREQUIRE((which() == Message::Message::ALLOCATE_FAILED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::AllocateFailed>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AllocateFailed::Builder Message::Message::Builder::getAllocateFailed() {
  KJ_IREQUIRE((which() == Message::Message::ALLOCATE_FAILED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::AllocateFailed>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::setAllocateFailed( ::AllocateFailed::Reader value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::ALLOCATE_FAILED);
  ::capnp::_::PointerHelpers< ::AllocateFailed>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AllocateFailed::Builder Message::Message::Builder::initAllocateFailed() {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::ALLOCATE_FAILED);
  return ::capnp::_::PointerHelpers< ::AllocateFailed>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::adoptAllocateFailed(
    ::capnp::Orphan< ::AllocateFailed>&& value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::ALLOCATE_FAILED);
  ::capnp::_::PointerHelpers< ::AllocateFailed>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AllocateFailed> Message::Message::Builder::disownAllocateFailed() {
  KJ_IREQUIRE((which() == Message::Message::ALLOCATE_FAILED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::AllocateFailed>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Message::Message::Reader::isFree() const {
  return which() == Message::Message::FREE;
}
inline bool Message::Message::Builder::isFree() {
  return which() == Message::Message::FREE;
}
inline bool Message::Message::Reader::hasFree() const {
  if (which() != Message::Message::FREE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Message::Message::Builder::hasFree() {
  if (which() != Message::Message::FREE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Free::Reader Message::Message::Reader::getFree() const {
  KJ_IREQUIRE((which() == Message::Message::FREE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Free>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Free::Builder Message::Message::Builder::getFree() {
  KJ_IREQUIRE((which() == Message::Message::FREE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Free>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::setFree( ::Free::Reader value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::FREE);
  ::capnp::_::PointerHelpers< ::Free>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Free::Builder Message::Message::Builder::initFree() {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::FREE);
  return ::capnp::_::PointerHelpers< ::Free>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::adoptFree(
    ::capnp::Orphan< ::Free>&& value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::FREE);
  ::capnp::_::PointerHelpers< ::Free>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Free> Message::Message::Builder::disownFree() {
  KJ_IREQUIRE((which() == Message::Message::FREE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Free>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Message::Message::Reader::isFreed() const {
  return which() == Message::Message::FREED;
}
inline bool Message::Message::Builder::isFreed() {
  return which() == Message::Message::FREED;
}
inline bool Message::Message::Reader::hasFreed() const {
  if (which() != Message::Message::FREED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Message::Message::Builder::hasFreed() {
  if (which() != Message::Message::FREED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Freed::Reader Message::Message::Reader::getFreed() const {
  KJ_IREQUIRE((which() == Message::Message::FREED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Freed>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Freed::Builder Message::Message::Builder::getFreed() {
  KJ_IREQUIRE((which() == Message::Message::FREED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Freed>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::setFreed( ::Freed::Reader value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::FREED);
  ::capnp::_::PointerHelpers< ::Freed>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Freed::Builder Message::Message::Builder::initFreed() {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::FREED);
  return ::capnp::_::PointerHelpers< ::Freed>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::adoptFreed(
    ::capnp::Orphan< ::Freed>&& value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::FREED);
  ::capnp::_::PointerHelpers< ::Freed>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Freed> Message::Message::Builder::disownFreed() {
  KJ_IREQUIRE((which() == Message::Message::FREED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::Freed>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Message::Message::Reader::isFreeFailed() const {
  return which() == Message::Message::FREE_FAILED;
}
inline bool Message::Message::Builder::isFreeFailed() {
  return which() == Message::Message::FREE_FAILED;
}
inline bool Message::Message::Reader::hasFreeFailed() const {
  if (which() != Message::Message::FREE_FAILED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Message::Message::Builder::hasFreeFailed() {
  if (which() != Message::Message::FREE_FAILED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::FreeFailed::Reader Message::Message::Reader::getFreeFailed() const {
  KJ_IREQUIRE((which() == Message::Message::FREE_FAILED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::FreeFailed>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::FreeFailed::Builder Message::Message::Builder::getFreeFailed() {
  KJ_IREQUIRE((which() == Message::Message::FREE_FAILED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::FreeFailed>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::setFreeFailed( ::FreeFailed::Reader value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::FREE_FAILED);
  ::capnp::_::PointerHelpers< ::FreeFailed>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::FreeFailed::Builder Message::Message::Builder::initFreeFailed() {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::FREE_FAILED);
  return ::capnp::_::PointerHelpers< ::FreeFailed>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Message::Message::Builder::adoptFreeFailed(
    ::capnp::Orphan< ::FreeFailed>&& value) {
  _builder.setDataField<Message::Message::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Message::Message::FREE_FAILED);
  ::capnp::_::PointerHelpers< ::FreeFailed>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::FreeFailed> Message::Message::Builder::disownFreeFailed() {
  KJ_IREQUIRE((which() == Message::Message::FREE_FAILED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::FreeFailed>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


